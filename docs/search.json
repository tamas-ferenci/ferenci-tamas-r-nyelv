[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Bevezetés az R nyelv és statisztikai számítási környezet használatába",
    "section": "",
    "text": "Előszó\nAz R egy ingyenes, nyílt forráskódú, rendkívüli tudású és folyamatosan fejlődő programozási nyelv illetve statisztikai számítási környezet, mely kiválóan alkalmas a legkülönfélébb statisztikai és adattudományi feladatok megoldására.\nAz R egyik fontos jellemzője, hogy lényegében minden feladat elvégzéshez egy szkriptet kell írnunk – szemben más statisztikai programokkal1, ahol csak egy grafikus felületen kell kattintgatnunk. Ez elsőre ijesztőnek hangozhat, és csakugyan igaz, hogy más programokhoz képest a tanulási görbe meredekebben indul, hiszen a kattintgatással szemben itt már két szám átlagolásához is programot kell írni. A dolog azonban kifizetődő: lehet, hogy egyszerű dolgokat más statisztikai környezetekben könnyebb végrehajtani, itt meg bonyolultabb, de cserében itt a bonyolultabbakat sem sokkal nehezebb, míg más statisztikai programokban az, vagy egyenesen lehetetlen. Kicsit is komolyabb elemzések, kutatások végzésekor az R megtanulásába befektettt munka hamar – és pláne: busásan – megtérül.\nA fentiekből már érthető, hogy ahhoz, hogy el tudjunk kezdeni statisztikai elemzéseket végezni R-ben, először az R-rel mint programozási nyelvvel kell megismerkedni. Nagyon fontos hangsúlyozni, hogy ez a jegyzet kizárólag az R nyelvi kérdéseivel és programozásával foglalkozik, az R statisztikai célokra történő felhasználása egy másik jegyzetem (Ferenci Tamás: Bevezetés a biostatisztikába) témája.\nAz R talán legnagyobb erejét a hozzá megírt, megszámlálhatatlan sok2 kiegészítő csomag adja, amikkel jószerével minden elképzelhető (és számos nehezen elképzelhető…) statisztikai feladat, adott esetben rendkívül bonyolultak is megoldhatóak, sokszor mindössze egy-egy függvényhívással. Számos kitűnő, jól dokumentált kiegészítő csomag érhető el (melyek maguk is ingyenesek és nyílt forráskódúak); nagyon tipikus, hogy a vadonatúj statisztikai módszereket is R-ben implementálják első közlésükkor. Az R csomagok központi repozitóriuma CRAN (Comprehensive R Archive Network).\nMindezek alapja az R mögött álló, rendkívül széles és erős nemzetközi közösség. Ingyenes programként bárki számára elérhető, nyílt forráskódú programként pedig jól bővíthető, illetve ez sokaknak a tudományra vonatkozó általános filozófiájával – „open science”, nyílt tudomány – is találkozik (így az enyémmel is). Számos statisztikus fejleszt R alá csomagokat, általában nagyon segítőkészek mind az esetleges hibák javításában, mind az új funkciók megvalósítására vonatkozóan. Több fórum érhető el (pl. a Stackoverflow), ahol a kezdőszintű egyszerű problémáktól a legspeciálisabb nehézségekig mindenben segítséget lehet kérni (és nem ritka, hogy a legnevesebb R fejlesztők válaszolnak!). Nagyon sok csomag jelen van a Github-on is, ami szintén kiváló platform az eszmecserére.\nAz R különösen erős az eredmények kommunikálásban. Kiegészítő csomagokkal könnyedén lehetséges ún. dinamikus dokumentumok készítése, melyek együtt tartalmazzák a kódokat, és a kapcsolódó leírást.\nA reprodukálható kutatás jegyében a cikkekkel együtt közzétett elemzések is nagyon gyakran R-ben íródtak, ezekből szintén sok ötlet meríthető.",
    "crumbs": [
      "Előszó"
    ]
  },
  {
    "objectID": "index.html#footnotes",
    "href": "index.html#footnotes",
    "title": "Bevezetés az R nyelv és statisztikai számítási környezet használatába",
    "section": "",
    "text": "Megjegyzendő, hogy az R-hez is létezik ilyen grafikus felület, az R Commander, azonban használata komolyabb elemzési feladatok elvégzéséhez nem szükséges, illetve nem hasznos, kezdők számára azonban kitűnő bevezető eszköz lehet, mivel a jól ismert statisztikai programokhoz teljesen hasonló grafikus felülettel ruházza fel az R-et.↩︎\n2021 őszén már több mint 18 ezer!↩︎",
    "crumbs": [
      "Előszó"
    ]
  },
  {
    "objectID": "rbevezetes.html",
    "href": "rbevezetes.html",
    "title": "1  R szkriptek és az RStudio",
    "section": "",
    "text": "Egy R-ben írt program, gyakrabban használt nevén szkript, R-beli utasítások sorozata. Lehet egyetlen sor, mely két számot átlagol, vagy több ezer utasításból felépülő komplex elemzés. Az R interpretált nyelv, nem fordított, ami azt jelenti, hogy nem a szkript egészét, egyben fordítja le számítógép által végrehajtható kóddá az R, hanem az utasításokat egyesével hajtja végre, utasításról utasításra.\nAz RStudio fejlesztői környezet alapbeállításában a bal oldali rész alján látható a konzol, ahol közvetlenül beküldhetünk utasításokat az R-nek, illetve az – akár közvetlenül, akár a lent vázolt módon szkriptből – beküldött utasítások eredményei láthatóak. A konzol felett találjuk a megnyitott szkriptet, vagy szkripteket. Új szkriptet megnyitni (vagy az elsőt megnyitni, ha még egy sincs nyitva – ez esetben a konzol az egész bal oldalt elfoglalja) a Ctrl+Shift+N billentyűkombinációval, vagy az ikonsor bal szélső ikonjára (fehér lap zöld plusz-jellel) kattintva, és ott az R Script pontot választva lehet.\nA konzolba írt utasítások azonnal végrehajtódnak (amint Enter-t ütünk, és ezzel beküldjük az utasítást az R-nek), a szkriptbe írt parancsok pedig a Ctrl+Enter billentyűkombinációval futtathatóak. (Valójában ez sem mond ellent annak a szabálynak, hogy a konzolba írt dolgok futtatódnak, mert ha jobban megfigyeljük, akkor láthatjuk, hogy a Ctrl+Enter igazából csak átmásolja az utasítást a konzolba, majd beküldi.) Ha a szkriptben nincs kijelölve semmi, akkor a Ctrl+Enter azt a sort futtatja, amiben a kurzur áll, ha ki van jelölve valami, akkor a kijelölést. (Függetlenül attól, hogy az milyen, lehet több sor is, de egy sor részlete is). Amint volt róla szó, egy utasítás több sorba is átnyúlhat, ez nem okoz problémát, ilyenkor az R megáll, és várja a további sorokat. Az RStudio ezeket szinte mindig felismeri, és okosan jár el: ilyenkor a Ctrl+Enter valójában nem egy sort fog beküldeni, hanem az egész utasítást, fontos azonban, hogy ehhez a legelső sorban kell állnunk. Az egész szkript Ctrl+Alt+R kombinációval futtatható le, az egész szkript addig a sorig, amiben a kurzor áll, a Ctrl+Alt+B kombinációval, az egész szkript az aktuális sortól a végéig Ctrl+Alt+E kombinációval futtatható.\nAz egyes utasításokat új sorban kell kezdeni (tehát enter-rel kell elválasztani egymástól). Elvileg egy sorba több utasítás is írható, ekkor az egyes utasításokat pontosvesszővel (;) kell elválasztani, de ezt minden körülmények között kerüljük.\nEgy utasítás több sorba is átnyúlhat, ezt az R érzékeli, tehát, ha a sor végén még nem záródott be egy utasítás, akkor a következő sorban folytatja a feldolgozást. Azt, hogy új utasítást vár az R, onnan lehet látni, hogy a konzol elején a &gt; jel látható. Ha az utasítás nem ér véget a sorban (ezt az R magától érzékeli, például onnan, hogy egy kinyitott zárójel nem lett bezárva a beküldött sorban), akkor automatikusan azt feltételezi, hogy ez azért van, mert a következő sorban folytatjuk az utasítást. Ilyenkor a konzol elején a &gt; helyett a + jel látható. Ez jelzi, hogy a beküldött utasítást a következő folytatásának tekinti. Amint látja az R, hogy bezárult az utasítás, végrehajtja, és a konzol átugrik újra a &gt; jelre: várja a következő utasítást. Ez a viselkedés egy gyakori hiba forrása: ha beküldünk egy utasítást, amiből véletlenül lehagyjuk a záró zárójelet, akkor az R várni fogja a folytatást. Ha azonban ezt nem vesszük észre, és beküldjük a következő utasítást, akkor nem azt fogja végre hajtani (ahogy várnánk), hanem az előző folytatásának tekinti, és úgy próbálja értelmezni. Az eredmény vagy hiba lesz, vagy az, hogy továbbra is + üzemmódban fogja várni az utasításokat, mi pedig nem kapunk eredményt. Ha ilyen történik, tehát küldjük be az utasításokat, amik teljesen helyesek, és mégsem kapunk eredményt, akkor érdemes megnézni, hogy nem + (folytatás) üzemmódban van-e az R. Ha igen, akkor küldjünk be záró zárójelet, ha ezzel sikerül lezárnunk az utasítást, akkor nyilván hibát kapunk, de legalább visszavehetjük az irányítást.\nAz aktuálisan szerkesztett szkript Ctrl+S utasítással, vagy az ikonsorban a kék színű, egy darab floppy-lemezes ikonra kattintva menthető. A R-szkriptek alapértelmezett kiterjesztése a .R. Fontos, hogy ezt betartsuk, ugyanis az RStudio funkcionalitása csak akkor fog működni, ha a fájlról tudja, hogy az egy R szkript, és ezt a kiterjesztés alapján azonosítja. A Ctrl+Alt+S parancs, vagy a kék színű, több floppy-lemezes ikon az összes megnyitott szkriptet menti. Az RStudio képes megőrizni a nem mentett szkripteket is kilépésnél (a nevük Untitled majd utána egy sorszám), de erre a lehetőségre azért ne nagyon építsünk, mert egy összeomlásnál elveszhetnek; a biztos a névvel lementett szkript. Mentett szkriptet megnyitni a Ctrl+O billentyűparanccsal, vagy az ikonsorban a mappából kifelé mutató zöld nyilas ikonnal lehet.\nMinden kicsit is komolyabb munkánkat érdemes szkriptben megírni, hiszen így lesz az elemzési munkafolyamat reprodukálható. A konzolt tipikusan csak gyors, ismétlődően nem igényelt egyszerű számításokhoz használjuk, aminek az eredményére később nem lesz szükségünk, vagy szkriptírás közben az apróbb bizonytalanságok eldöntéséhez (mi is lesz ennek a parancsnak az eredménye?) használjuk.\nA kódunkat érdemes kommentelni, hogy később is világos legyen a működése. A komment olyan része a szkriptnek, melyet az R nem hajt végre, hiszen tudja, hogy nem R utasítás, hanem természetes nyelven írt megjegyzés. Ennek elkülönítésére a kommentjel szolgál, ez az R-ben a #: amennyiben az R egy ilyenhez ér, onnantól átugorja a leírtakat egészen a sor végéig. (Ez tehát ún. egysoros kommentjel.) A # az RStudio-ban a Ctrl+Shift+C-vel szúrható be gyorsan: azon sort kommentezi, mégpedig az elejétől fogva, amelyikben a kurzur áll, illetve ha ki van kommentezve, akkor ezt megszünteti. Többsoros kommentre nincs külön jel R-ben, viszont RStudio-ban a Ctrl+Shift+C használható több sort kijelölve is, ekkor mindegyiket kommentezi (vagy eltünteti a kommentjelet, ha ki vannak kommentezve).\nAz R kisbetű/nagybetű különbségre érzékeny (case sensitive) nyelv, tehát az a és az A nem ugyanaz, két különböző dolog.\nAz RStudio nagyon sok eszközzel segíti a kódolást: színekkel jelöli a különböző tartalmú szintaktikai elemeket, elkezdve egy nevet beírni, Tab-bal kiegészíti azt (automatikusan, ha csak egy lehetőség van, egy listát ad, ha több is), rövidebb vagy hosszabb súgót jelenít meg közvetlenül a beírt kód mellett stb. Segíti a kód identálását: a Ctrl+I kombináció szépen beindentálja a kijelölt részt. (Tipikus a Ctrl+A majd Ctrl+I kombináció: az előbbi kijelöli az egész szkriptet, így tehát ez mindent identál.)\nAz R kódolási stílus kapcsán csak egyetlen megjegyzés elöljáróban: vessző után rakjunk szóközt, de nyitó zárójel után, illetve záró zárójel előtt ne.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>R szkriptek és az RStudio</span>"
    ]
  },
  {
    "objectID": "adattipusokadatszerkezetek.html",
    "href": "adattipusokadatszerkezetek.html",
    "title": "2  Adattípusok, adatszerkezetek",
    "section": "",
    "text": "2.1 Értékadás\nVáltozó értéket az értékadás művelettel kap; ez kb. a ,,legyen egyenlő’’ módon olvasható ki. Az értékedás jele az R-ben a &lt;-. (A más programnyelveken megszokottabb =-t ne használjuk értékadásra, mert bár működne, de az R-es hagyományok szerint ezt egy másik helyzetre tartjuk fent, amit később látni is fogunk). A nyíl bal oldalára kerül a változó, a jobb oldalára az érték, amit adni akarunk neki. Elvileg használható a -&gt; is értékadásra, ilyenkor értelemszerűen fordul a helyzet, de ezt ritkán szokták alkalmazni.\nÍme egy értékadás:\na &lt;- 1\nAmi szembeötlik (pláne, ha valakinek más, szigorúbb programnyelvből van háttere): ez az utasítás gond nélkül lefut, miközben sehol nem deklaráltuk, hogy az a legyen egy változó, pláne nem adtuk meg, hogy milyen típusú adatot akarunk benne tárolni! Az R ,,intelligensen’’ kitalált mindent: mivel látja, hogy korábban a nevű változó még nem létezett, ezért egyetlen szó nélkül, automatikusan létrehozza, illetve abból, hogy mit adtunk neki értékül, azt is meghatározta, hogy milyen legyen a típusa, jelen esetben szám. Majd természetesen az értékét is beállítja arra, amit megadtunk. Már létező változónak történő értékadásnál az előző érték elveszlik, és felülíródik az aktuálisan megadottal.\nEz egy példa az R egy meglehetősen általános filozófiájára, amire később még sok további példát fogunk látni: hogy az R ,,megengedi trehányságot’’ és igyekszik kitalálni, hogy mit akarhattunk. Bár ez első ránézésre rendkívül kényelmesnek hangzik, fontos hangsúlyozni, hogy ez egy kétélű fegyver! Egyfelől ugyanis valóban nagyon kényelmes, jelen esetben, hogy nem kell törődnünk a változók előzetes deklarálásával, típusuk megadásával, de másrészt így kiesik egy védővonal, ami megóvhatna minket a saját hibáinktól – hiszen a deklaráció rákényszerít(ett volna) minket arra, hogy jobban végiggondoljuk a változókkal kapcsolatos kérdéseket. Így viszont könnyebben előfordulhat, hogy olyat csinálunk, amit igazából nem szeretnénk, ráadásul úgy, hogy észre sem vesszük! Elírjuk a változó nevét, és nem figyelmeztetést kapunk, hogy de hát ilyen változó nem létezik, hanem egyetlen hang nélkül létrejön egy új, hibás nevű (miközben az igazi értéke marad változatlan). Egy eredetileg szám típusú változónak értékül adunk egy szöveget, és ez egyetlen hang nélkül lefut, lecserélve a változó típusát.\nR-ben a változónév karakterekből, számokból, a . és a _ jelekből állhat, de nem kezdődhet számmal vagy _ jellel, és ha . jellel kezdődik, akkor utána nem jöhet szám. (Bizonyos, úgynevezett foglalt szavakat, amiket az R nyelv használ, nem választhatunk változónévnek. Ezekből nagyon kevés van, így annyiban óvatosnak kell lenni, hogy az R egy sor szokásos függvényét simán felüldefiniálhatjunk, ha létrehozunk olyan nevű változót.) Érdekes módon az, hogy az R mit ért karakter alatt, függhet az adott számítógép beállításaitól, de a legbiztosabb, ha a standard latin betűs (ASCII) karaktereket használjuk csak. (Azaz: lehetőleg ne használjunk ékezetes betűt változónévként. Elvileg el lehet vele boldogulni – adott esetben speciális szimbólummal jelölve, hogy az egy változónév – de nem éri meg a vesződséget, csomagokban kiszámíthatatlan gondokat okozhat.)\nEgy fontos általános szabály, hogy ha egy utasításban értékadás van, akkor az eltárolás a ,,háttérben’’ történik meg, a konzolra nem íródik ki semmi. (Természetesen vannak kivételek, olyan számítások, amik mellékhatásként mindenképp kiírnak valamit a konzolra.) Értékadás nélküli utasítás futtatásánál viszont épp fordított a helyzet: az eredmény kiíratódik a konzolra, de nem tárolódik el sehol. Ha egy értékadást gömbölyű zárójelekbe ágyazunk ((a &lt;- 1)), akkor el is tárolódik és ki is íratódik az eredmény; a gyakorlatban ritkán használjuk.\n(Egy apró jótanács. Mi van akkor, ha lefuttatunk egy rendkívül hosszú utasítást, de véletlenül elfelejtjük benyilazni egy változóba… azaz az eredmény megjelenik a konzolon, viszont nem tárolódott le! Most futtathatjuk az egészet újra?! Szerencsére nem: az R valójában nyíl nélkül is eltárolja egy speciális változóban az eredményt, a neve .Last.value. Ha tehát ilyen történik, akkor ne essünk kétségbe, ezt speciális változót adjuk értékül a változónknak. De vigyázzunk, ilyen módon mindig csak a legutóbbi utasítás eredménye érhető el.)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Adattípusok, adatszerkezetek</span>"
    ]
  },
  {
    "objectID": "adattipusokadatszerkezetek.html#adattípusok",
    "href": "adattipusokadatszerkezetek.html#adattípusok",
    "title": "2  Adattípusok, adatszerkezetek",
    "section": "2.2 Adattípusok",
    "text": "2.2 Adattípusok\nElsőként meg kell ismerkednünk azzal, hogy a korábban említett típusok pontosan milyenek lehetnek – ez lényegében azt adja meg, hogy milyen jellegű adatot tárolunk az adott változóban. Az R-ben 4 fontos adattípus van: numerikus, amelybe a valós és az egész típusok tartoznak alcsoportként, a szöveg és a logikai. (Elvileg még két további típus létezik, a complex és a raw, ezek nagyon ritkán használatosak.) Létezik még egy fogalom, a factor, ami adattípusnak tűnik, de mégsem az (egy másik típus speciális esete), erről később fogunk szót ejteni.\nA változó típusát az R többféle módon is értelmezi, de a gyakorlatban inkább az str függvény ismerete a fontosabb, mellyel komplexebb adatszerkezetekről is jól áttekinthető információt tudunk nyerni.\n\n2.2.1 Numerikus\nSzámok tárolására a numerikus típus (numeric, rövidítve num) szolgál.\nAlapbeállításban ez a típus valós számokat tárol (precízen: double pontosságú lebegőpontos). A double pontossága jellemzően 53 bit (kb. \\(2\\cdot 10^{-308}\\)-tól \\(2\\cdot 10^{308}\\)-ig nagyjából \\(2\\cdot 10^{-16}\\) felbontással; az adott architektúra vonatkozó értéket a .Machine megmondja).\nAz R-ben a tizedestörteket angol stílusban kell megadni, tehát a tizedesjelölő a pont, nem a vessző.\nÍgy néz ki egy numerikus adattal történő értékadás:\n\nszam &lt;- 3.1\nszam\n\n[1] 3.1\n\nstr(szam)\n\n num 3.1\n\n\nNézzük meg, hogy csakugyan case sensitive a nyelv:\n\nSZAM\n\nError: object 'SZAM' not found\n\nSzam\n\nError: object 'Szam' not found\n\nszaM\n\nError: object 'szaM' not found\n\n\nFontos megjegyezni, hogy attól mert valami történetesen egész, az R még nem fogja egész számként kezelni, ugyanúgy valósnak veszi:\n\nszam &lt;- 3\nstr(szam)\n\n num 3\n\n\nHa egészet (integer) akarunk, azt explicite jelölni kell a szám után fűzött L utótaggal:\n\negesz &lt;- 3L\negesz\n\n[1] 3\n\nstr(egesz)\n\n int 3\n\n\n\n\n2.2.2 Szöveg\nSzemben más programnyelvvek, az R-ben nincs megkülönböztetve az egy karakter, és a több karakterből álló karakterfüzér (sztring). Számára mindkettő ugyanolyan típusú (character, rövidítve chr).\nSzöveg:\n\nszoveg &lt;- \"kiskutya\"\nszoveg\n\n[1] \"kiskutya\"\n\nstr(szoveg)\n\n chr \"kiskutya\"\n\nmasikszoveg &lt;- \"a\"\nmasikszoveg\n\n[1] \"a\"\n\nstr(masikszoveg)\n\n chr \"a\"\n\n\nMint látható, a sztringkonstansokat idézőjellel kell jelölni. Az R megengedi a dupla (\" \") és a szimpla (' ') idézőjel használatát is, de az előbbi a preferált (az R általi kiírás is mindenképp ilyennel történik), az utóbbit érdemes az egymásbaágyazott esetekre használni (tehát, ha egy sztringkonstans tartalmaz egy idézőjeles részt).\nTermészetesen az \"1\" kifejezés nem az 1 számot, hanem az 1-et (mint karaktert) tartalmazó sztringet jelenti! A sztringet tehát mindig jelölni kell (különben a kiskutya beírásakor egy ilyen nevű változót kezdene keresni az R).\n\n\n2.2.3 Logikai\nLogikai (logical, rövidítve logi) típusú változóban igaz/hamis értékeket tárolhatunk:\n\nlogikai &lt;- TRUE\nlogikai\n\n[1] TRUE\n\nstr(logikai)\n\n logi TRUE\n\n\nA TRUE rövidíthető T-nek, a FALSE pedig F-nek.\n\n\n2.2.4 Az adattípusokhoz kapcsolódó néhány fontos művelet\nAdott típus tesztelése az is.&lt;tipus&gt; alakban lehet:\n\nis.integer(szam)\n\n[1] FALSE\n\nis.integer(egesz)\n\n[1] TRUE\n\nis.integer(szoveg)\n\n[1] FALSE\n\nis.integer(logikai)\n\n[1] FALSE\n\n\nAz is.numeric azt jelenti, hogy is.integer vagy is.double:\n\nis.double(szam)\n\n[1] TRUE\n\nis.double(egesz)\n\n[1] FALSE\n\nis.numeric(szam)\n\n[1] TRUE\n\nis.numeric(egesz)\n\n[1] TRUE\n\n\nAdott típussá alakítás as.&lt;tipus&gt; alakban lehet:\n\nas.character(szam)\n\n[1] \"3\"\n\nas.numeric(szoveg)\n\nWarning: NAs introduced by coercion\n\n\n[1] NA\n\nas.numeric(\"2.4\" )\n\n[1] 2.4\n\nas.numeric(logikai)\n\n[1] 1\n\n\nA sémát már a fentiek is mutatják: a konvertálásnál egy ,,erősorrend’’, jelesül character &lt; double = integer &lt; logical, amely irányban mindig lehet konvertálni (a T 1-re, a F 0-ra alakul, a többi értelemszerű). A sorrenddel ellentétesen is elképzelhető, hogy lehet konvertálni, de ez már nem biztos, azon múlik, hogy értelmesen végrehajtható-e (a \"kiskutya\" nem konvertálható számmá, az \"1\" igen). Sok függvény automatikusan konvertál, például ha egy logikai igaz értékhez hozzáadunk 1-et, akkor 2-t kapunk, mert a háttérben, szó nélkül, át fogja konvertálni számmá.\nA sikertelen konverziók NA-t adnak, amely az R-ben lényegében a ,,hiányzó érték’’ jele.\nSpeciális szerepe van még a NULL-nak (ez inkább olyasmit jelöl, hogy ,,üres objektum’’), illetve az NaN-nek (not-a-number, tipikusan olyan adja, mint például ha negatív szám logaritmusát vesszük).",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Adattípusok, adatszerkezetek</span>"
    ]
  },
  {
    "objectID": "adattipusokadatszerkezetek.html#adatszerkezetek-és-indexelés",
    "href": "adattipusokadatszerkezetek.html#adatszerkezetek-és-indexelés",
    "title": "2  Adattípusok, adatszerkezetek",
    "section": "2.3 Adatszerkezetek és indexelés",
    "text": "2.3 Adatszerkezetek és indexelés\nMost, hogy ismerjük az adattípusokat, azzal kell folytatnunk, hogy ezekből milyen komplexebb struktúrák rakhatóak össze.\n\n2.3.1 Vektor\nA vektor homogén, egydimenziós adatszerkezet. Egydimenziós, mert egy ,,kiterjedése’’ van, egy indexszel hivatkozhatunk az elemeire, és homogén, mert minden benne lévő adat ugyanolyan típusú kell legyen. Szemben a ,,vektor’’ matematikai fogalmával, nem kötelező, hogy ezek számok legyenek, de mindenképp ugyanolyannak kell lennie a típusuknak.\nVektor legegyszerűbb módon az elemei felsorolásával hozható létre, ehhez a c függvény használható:\n\nszamvektor &lt;- c(1, 4, 5, -2, 3.5, 10)\nszamvektor\n\n[1]  1.0  4.0  5.0 -2.0  3.5 10.0\n\n\nSok függvény vektort ad vissza eredményül, például a seq-val generálhatunk egy reguláris sorozatot. A függvényekről később lesz szó, úgyhogy most kommentár nélkül: a seq(1, 101, 2) hívás kidobja a számokat 1-től 101-ig 2-esével:\n\nseq(1, 101, 2)\n\n [1]   1   3   5   7   9  11  13  15  17  19  21  23  25  27  29  31  33  35  37\n[20]  39  41  43  45  47  49  51  53  55  57  59  61  63  65  67  69  71  73  75\n[39]  77  79  81  83  85  87  89  91  93  95  97  99 101\n\n\nAz eredmény egy vektor.\nArra a speciális esetre, hogy 1-esével lépkedünk, olyan sűrűn van szükség, hogy arra van egy külön, rövidebb jelölés, a ::\n\n1:100\n\n  [1]   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18\n [19]  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36\n [37]  37  38  39  40  41  42  43  44  45  46  47  48  49  50  51  52  53  54\n [55]  55  56  57  58  59  60  61  62  63  64  65  66  67  68  69  70  71  72\n [73]  73  74  75  76  77  78  79  80  81  82  83  84  85  86  87  88  89  90\n [91]  91  92  93  94  95  96  97  98  99 100\n\n\nA sorok elején lévő, szögletes zárójelbe írt számok nem részei a vektornak, az az olvashatóságot segíti: ha nagyon hosszú vektorban kell egy adott elem pozícióját megtalálni, akkor nem a legelejétől kell számolni, elég a sor elejétől menni.\nFeltűnhet, hogy a korábbi szam kiíratás esetén is megjelent egy [1] a sor elején. Ez nem véletlen: a valóságban ,,skalár’’ nincs az R-ben, igazából a szam is egy vektor (csak épp egy elemből áll).\nAhogy volt róla szó, nem csak numerikus adatokból képezhető vektor, hanem bármilyenből:\n\nkaraktervektor &lt;- c(\"a\", \"b\", \"xyz\")\nkaraktervektor\n\n[1] \"a\"   \"b\"   \"xyz\"\n\n\nA vektor homogén, ezért az alábbi utasítások csak és kizárólag azért futnak le mégis, mert a háttérben ilyenkor az R a ,,leggyengébbre’’ konvertálja az összeset (hogy kikényszerítse a homogenitást):\n\nc(1, \"a\")\n\n[1] \"1\" \"a\"\n\nc(2, TRUE)\n\n[1] 2 1\n\n\nA vektor elemei el is nevezhetőek; a nevek később a names-zel lekérhetőekk:\n\nszamvektor &lt;- c(elso = 4, masodik = 1, harmadik = 7)\nszamvektor\n\n    elso  masodik harmadik \n       4        1        7 \n\nnames(szamvektor)\n\n[1] \"elso\"     \"masodik\"  \"harmadik\"\n\n\nA names érdekesen viselkedik, mert nem csak megadja a neveket, de bele is nyilazhatunk értéket, ez esetben beállítja:\n\nnames(szamvektor) &lt;- c(\"egy\", \"ketto\", \"harom\")\nszamvektor\n\n  egy ketto harom \n    4     1     7 \n\n\nAz adatszerkezetek esetén egy alapvető kérdés az indexelés, tehát, hogy hogyan hivatkozhatunk adott pozicióban lévő elemre vagy elemekre. Ennek az R-ben meglehetősen sok módja lehetséges, de általános, hogy az indexelést a szögletes zárójel jelöli. (Később fogunk még egy szintaktikai elemet látni indexelésre.)\nA legegyszerűbb eset, ha egyetlen számmal indexelünk: ekkor az adott pozícióban lévő elemet kapjuk meg. Például:\n\nszamvektor[3]\n\nharom \n    7 \n\n\nMegtehetjük azt is, hogy nem egy számot, hanem egy vektort adunk át, ekkor a felsorolt pozícióban lévő elemeket kapjuk, a felsorolás sorrendjében:\n\nszamvektor[c(1, 3)]\n\n  egy harom \n    4     7 \n\n\n(Ugye látjuk, hogy ez a kettő igazából ugyanaz? Az előbbi példa is vektorral indexeltm hiszen ,,egy szám’’ nincsen, az is vektor.)\nEgy elem kiválasztható többször is, illetve tetszőleges sorrendben:\n\nszamvektor[c(2, 2, 1, 3, 2, 3, 1, 1)]\n\nketto ketto   egy harom ketto harom   egy   egy \n    1     1     4     7     1     7     4     4 \n\n\nNemlétező elem indexelése NA-t ad:\n\nszamvektor[10]\n\n&lt;NA&gt; \n  NA \n\n\nA második alapvető megoldás a logikai vektorral való indexelés: ekkor egy ugyanolyan hosszú vektort kell átadnunk, mint az indexelendő vektor, és azokat az elemeke választja ki, ahol logikai igaz érték van:\n\nszamvektor[c(TRUE, FALSE, TRUE, TRUE, FALSE, TRUE)]\n\n  egy harom  &lt;NA&gt;  &lt;NA&gt; \n    4     7    NA    NA \n\n\nValójában azonban ez is működik, hiába rövidebb az indexelő vektor:\n\nszamvektor[c(TRUE, TRUE, FALSE)]\n\n  egy ketto \n    4     1 \n\n\nEz egy újabb példa a kétélű flexibilitásra: azért fog működni, mert ilyenkor az R ,,reciklálja’’ az indexelő vektort.\nLehetséges negatív indexelés is, ez kiválaszt mindent, kivéve amit indexeltünk:\n\nszamvektor[-3]\n\n  egy ketto \n    4     1 \n\nszamvektor[-c(1, 3)]\n\nketto \n    1 \n\n\nHa vannak elnevezések, akkor azok használhatóak indexelésre is:\n\nszamvektor[\"masodik\"]\n\n&lt;NA&gt; \n  NA \n\nszamvektor[c(\"masodik\", \"utolso\")]\n\n&lt;NA&gt; &lt;NA&gt; \n  NA   NA \n\n\nAz indexelés és az értékadás kombinálható is:\n\nszamvektor[ 3 ] &lt;- 99\nszamvektor\n\n  egy ketto harom \n    4     1    99 \n\nszamvektor[ 10 ]\n\n&lt;NA&gt; \n  NA \n\n\nHa nemlétezőnek adunk értéket, automatikusan kiterjeszti a vektort, a többi helyre pedig NA kerül (megint újabb példa a kétélű flexibilitásra):\n\nszamvektor[ 10 ] &lt;- 999\nszamvektor\n\n  egy ketto harom                                           \n    4     1    99    NA    NA    NA    NA    NA    NA   999 \n\n\n\n\n2.3.2 Mátrix\nA mátrix homogén, kétdimenziós adatszerkezet.\nLegegyszerűbben úgy tölthető fel, ha egy vektort áttördelünk, a matrix függvény használatával (az nc argumentummal az oszlopok, az nr argumentummal a sorok számát állíthatjuk be, értelemszerűen elég a kettőből egyet megadni):\n\nszammatrix &lt;- matrix( 1:6, nc = 2 )\nszammatrix\n\n     [,1] [,2]\n[1,]    1    4\n[2,]    2    5\n[3,]    3    6\n\n\nAlapból oszlopok szerint tördel, de a byrow argumentummal ezt átállíthatjuk:\n\nmatrix( 1:6, nc = 2, byrow = TRUE )\n\n     [,1] [,2]\n[1,]    1    2\n[2,]    3    4\n[3,]    5    6\n\n\nA dimenzió, illetve külön a sorok és oszlopok száma könnyen lekérhető:\n\ndim( szammatrix )\n\n[1] 3 2\n\nnrow( szammatrix )\n\n[1] 3\n\nncol( szammatrix )\n\n[1] 2\n\n\nA mátrix oszlopai és sorai is elnevezhetőek, emiatt itt nem egy names van, hanem egy row.names és egy names, ez utóbbi az oszlopnév, de egyebekben teljesen hasonlóan viselkednek.\nIndexelés ugyanúgy végezhető, csak épp mindkét dimenzióra mondanunk kell valamit; a kettő vesszővel választandó el:\n\nszammatrix[ c( 2, 3 ), 2 ]\n\n[1] 5 6\n\n\nMindkét dimenzió tetszőleges korábban látott módon indexelhető, tehát a különböző módok keverhetőek is:\n\nszammatrix[ c( 1, 2 ), c( T, F ) ]\n\n[1] 1 2\n\n\nHa egy dimenziót nem indexelünk, akkor az R úgy érti, hogy onnan minden elem (de a vessző ekkor sem hagyható el!):\n\nszammatrix[ 2, ]\n\n[1] 2 5\n\n\n\n\n2.3.3 Tömb (array)\nA tömb (array) homogén, \\(n\\)-dimenziós adatszerkezet (nem foglalkozunk vele részletesebben, ritkán használatos).\n\n\n2.3.4 Data frame\nA data frame (adatkeret) heterogén, kétdimenziós, rektanguláris adatszerkezet. Pontosabban szólva félig heterogén: az oszlopok homogének, de a különböző oszlopok típusai eltérhetnek egymástól. Lényegében tehát - nem feltétlenül ugyanolyan típusú - vektorok összefogva; a rektanguláris azt jelenti, hogy minden vektor ugyanolyan hosszú kell legyen.\nEz a legtipikusabb adatszerkezet orvosi adatok tárolására: sorokban a megfigyelési egységek, oszlopokban a változók.\nA data paranccsal egy kiegészítő csomagban található kész adat tölthető be:\n\ndata( birthwt, package = \"MASS\" )\nbirthwt\n\n    low age lwt race smoke ptl ht ui ftv  bwt\n85    0  19 182    2     0   0  0  1   0 2523\n86    0  33 155    3     0   0  0  0   3 2551\n87    0  20 105    1     1   0  0  0   1 2557\n88    0  21 108    1     1   0  0  1   2 2594\n89    0  18 107    1     1   0  0  1   0 2600\n91    0  21 124    3     0   0  0  0   0 2622\n92    0  22 118    1     0   0  0  0   1 2637\n93    0  17 103    3     0   0  0  0   1 2637\n94    0  29 123    1     1   0  0  0   1 2663\n95    0  26 113    1     1   0  0  0   0 2665\n96    0  19  95    3     0   0  0  0   0 2722\n97    0  19 150    3     0   0  0  0   1 2733\n98    0  22  95    3     0   0  1  0   0 2751\n99    0  30 107    3     0   1  0  1   2 2750\n100   0  18 100    1     1   0  0  0   0 2769\n101   0  18 100    1     1   0  0  0   0 2769\n102   0  15  98    2     0   0  0  0   0 2778\n103   0  25 118    1     1   0  0  0   3 2782\n104   0  20 120    3     0   0  0  1   0 2807\n105   0  28 120    1     1   0  0  0   1 2821\n106   0  32 121    3     0   0  0  0   2 2835\n107   0  31 100    1     0   0  0  1   3 2835\n108   0  36 202    1     0   0  0  0   1 2836\n109   0  28 120    3     0   0  0  0   0 2863\n111   0  25 120    3     0   0  0  1   2 2877\n112   0  28 167    1     0   0  0  0   0 2877\n113   0  17 122    1     1   0  0  0   0 2906\n114   0  29 150    1     0   0  0  0   2 2920\n115   0  26 168    2     1   0  0  0   0 2920\n116   0  17 113    2     0   0  0  0   1 2920\n117   0  17 113    2     0   0  0  0   1 2920\n118   0  24  90    1     1   1  0  0   1 2948\n119   0  35 121    2     1   1  0  0   1 2948\n120   0  25 155    1     0   0  0  0   1 2977\n121   0  25 125    2     0   0  0  0   0 2977\n123   0  29 140    1     1   0  0  0   2 2977\n124   0  19 138    1     1   0  0  0   2 2977\n125   0  27 124    1     1   0  0  0   0 2922\n126   0  31 215    1     1   0  0  0   2 3005\n127   0  33 109    1     1   0  0  0   1 3033\n128   0  21 185    2     1   0  0  0   2 3042\n129   0  19 189    1     0   0  0  0   2 3062\n130   0  23 130    2     0   0  0  0   1 3062\n131   0  21 160    1     0   0  0  0   0 3062\n132   0  18  90    1     1   0  0  1   0 3062\n133   0  18  90    1     1   0  0  1   0 3062\n134   0  32 132    1     0   0  0  0   4 3080\n135   0  19 132    3     0   0  0  0   0 3090\n136   0  24 115    1     0   0  0  0   2 3090\n137   0  22  85    3     1   0  0  0   0 3090\n138   0  22 120    1     0   0  1  0   1 3100\n139   0  23 128    3     0   0  0  0   0 3104\n140   0  22 130    1     1   0  0  0   0 3132\n141   0  30  95    1     1   0  0  0   2 3147\n142   0  19 115    3     0   0  0  0   0 3175\n143   0  16 110    3     0   0  0  0   0 3175\n144   0  21 110    3     1   0  0  1   0 3203\n145   0  30 153    3     0   0  0  0   0 3203\n146   0  20 103    3     0   0  0  0   0 3203\n147   0  17 119    3     0   0  0  0   0 3225\n148   0  17 119    3     0   0  0  0   0 3225\n149   0  23 119    3     0   0  0  0   2 3232\n150   0  24 110    3     0   0  0  0   0 3232\n151   0  28 140    1     0   0  0  0   0 3234\n154   0  26 133    3     1   2  0  0   0 3260\n155   0  20 169    3     0   1  0  1   1 3274\n156   0  24 115    3     0   0  0  0   2 3274\n159   0  28 250    3     1   0  0  0   6 3303\n160   0  20 141    1     0   2  0  1   1 3317\n161   0  22 158    2     0   1  0  0   2 3317\n162   0  22 112    1     1   2  0  0   0 3317\n163   0  31 150    3     1   0  0  0   2 3321\n164   0  23 115    3     1   0  0  0   1 3331\n166   0  16 112    2     0   0  0  0   0 3374\n167   0  16 135    1     1   0  0  0   0 3374\n168   0  18 229    2     0   0  0  0   0 3402\n169   0  25 140    1     0   0  0  0   1 3416\n170   0  32 134    1     1   1  0  0   4 3430\n172   0  20 121    2     1   0  0  0   0 3444\n173   0  23 190    1     0   0  0  0   0 3459\n174   0  22 131    1     0   0  0  0   1 3460\n175   0  32 170    1     0   0  0  0   0 3473\n176   0  30 110    3     0   0  0  0   0 3544\n177   0  20 127    3     0   0  0  0   0 3487\n179   0  23 123    3     0   0  0  0   0 3544\n180   0  17 120    3     1   0  0  0   0 3572\n181   0  19 105    3     0   0  0  0   0 3572\n182   0  23 130    1     0   0  0  0   0 3586\n183   0  36 175    1     0   0  0  0   0 3600\n184   0  22 125    1     0   0  0  0   1 3614\n185   0  24 133    1     0   0  0  0   0 3614\n186   0  21 134    3     0   0  0  0   2 3629\n187   0  19 235    1     1   0  1  0   0 3629\n188   0  25  95    1     1   3  0  1   0 3637\n189   0  16 135    1     1   0  0  0   0 3643\n190   0  29 135    1     0   0  0  0   1 3651\n191   0  29 154    1     0   0  0  0   1 3651\n192   0  19 147    1     1   0  0  0   0 3651\n193   0  19 147    1     1   0  0  0   0 3651\n195   0  30 137    1     0   0  0  0   1 3699\n196   0  24 110    1     0   0  0  0   1 3728\n197   0  19 184    1     1   0  1  0   0 3756\n199   0  24 110    3     0   1  0  0   0 3770\n200   0  23 110    1     0   0  0  0   1 3770\n201   0  20 120    3     0   0  0  0   0 3770\n202   0  25 241    2     0   0  1  0   0 3790\n203   0  30 112    1     0   0  0  0   1 3799\n204   0  22 169    1     0   0  0  0   0 3827\n205   0  18 120    1     1   0  0  0   2 3856\n206   0  16 170    2     0   0  0  0   4 3860\n207   0  32 186    1     0   0  0  0   2 3860\n208   0  18 120    3     0   0  0  0   1 3884\n209   0  29 130    1     1   0  0  0   2 3884\n210   0  33 117    1     0   0  0  1   1 3912\n211   0  20 170    1     1   0  0  0   0 3940\n212   0  28 134    3     0   0  0  0   1 3941\n213   0  14 135    1     0   0  0  0   0 3941\n214   0  28 130    3     0   0  0  0   0 3969\n215   0  25 120    1     0   0  0  0   2 3983\n216   0  16  95    3     0   0  0  0   1 3997\n217   0  20 158    1     0   0  0  0   1 3997\n218   0  26 160    3     0   0  0  0   0 4054\n219   0  21 115    1     0   0  0  0   1 4054\n220   0  22 129    1     0   0  0  0   0 4111\n221   0  25 130    1     0   0  0  0   2 4153\n222   0  31 120    1     0   0  0  0   2 4167\n223   0  35 170    1     0   1  0  0   1 4174\n224   0  19 120    1     1   0  0  0   0 4238\n225   0  24 116    1     0   0  0  0   1 4593\n226   0  45 123    1     0   0  0  0   1 4990\n4     1  28 120    3     1   1  0  1   0  709\n10    1  29 130    1     0   0  0  1   2 1021\n11    1  34 187    2     1   0  1  0   0 1135\n13    1  25 105    3     0   1  1  0   0 1330\n15    1  25  85    3     0   0  0  1   0 1474\n16    1  27 150    3     0   0  0  0   0 1588\n17    1  23  97    3     0   0  0  1   1 1588\n18    1  24 128    2     0   1  0  0   1 1701\n19    1  24 132    3     0   0  1  0   0 1729\n20    1  21 165    1     1   0  1  0   1 1790\n22    1  32 105    1     1   0  0  0   0 1818\n23    1  19  91    1     1   2  0  1   0 1885\n24    1  25 115    3     0   0  0  0   0 1893\n25    1  16 130    3     0   0  0  0   1 1899\n26    1  25  92    1     1   0  0  0   0 1928\n27    1  20 150    1     1   0  0  0   2 1928\n28    1  21 200    2     0   0  0  1   2 1928\n29    1  24 155    1     1   1  0  0   0 1936\n30    1  21 103    3     0   0  0  0   0 1970\n31    1  20 125    3     0   0  0  1   0 2055\n32    1  25  89    3     0   2  0  0   1 2055\n33    1  19 102    1     0   0  0  0   2 2082\n34    1  19 112    1     1   0  0  1   0 2084\n35    1  26 117    1     1   1  0  0   0 2084\n36    1  24 138    1     0   0  0  0   0 2100\n37    1  17 130    3     1   1  0  1   0 2125\n40    1  20 120    2     1   0  0  0   3 2126\n42    1  22 130    1     1   1  0  1   1 2187\n43    1  27 130    2     0   0  0  1   0 2187\n44    1  20  80    3     1   0  0  1   0 2211\n45    1  17 110    1     1   0  0  0   0 2225\n46    1  25 105    3     0   1  0  0   1 2240\n47    1  20 109    3     0   0  0  0   0 2240\n49    1  18 148    3     0   0  0  0   0 2282\n50    1  18 110    2     1   1  0  0   0 2296\n51    1  20 121    1     1   1  0  1   0 2296\n52    1  21 100    3     0   1  0  0   4 2301\n54    1  26  96    3     0   0  0  0   0 2325\n56    1  31 102    1     1   1  0  0   1 2353\n57    1  15 110    1     0   0  0  0   0 2353\n59    1  23 187    2     1   0  0  0   1 2367\n60    1  20 122    2     1   0  0  0   0 2381\n61    1  24 105    2     1   0  0  0   0 2381\n62    1  15 115    3     0   0  0  1   0 2381\n63    1  23 120    3     0   0  0  0   0 2410\n65    1  30 142    1     1   1  0  0   0 2410\n67    1  22 130    1     1   0  0  0   1 2410\n68    1  17 120    1     1   0  0  0   3 2414\n69    1  23 110    1     1   1  0  0   0 2424\n71    1  17 120    2     0   0  0  0   2 2438\n75    1  26 154    3     0   1  1  0   1 2442\n76    1  20 105    3     0   0  0  0   3 2450\n77    1  26 190    1     1   0  0  0   0 2466\n78    1  14 101    3     1   1  0  0   0 2466\n79    1  28  95    1     1   0  0  0   2 2466\n81    1  14 100    3     0   0  0  0   2 2495\n82    1  23  94    3     1   0  0  0   0 2495\n83    1  17 142    2     0   0  1  0   0 2495\n84    1  21 130    1     1   0  1  0   3 2495\n\n\nCsak a felső néhány sor a head paranccsal kérhető le (az alsó néhány sor pedig a tail-lel):\n\nhead( birthwt )\n\n   low age lwt race smoke ptl ht ui ftv  bwt\n85   0  19 182    2     0   0  0  1   0 2523\n86   0  33 155    3     0   0  0  0   3 2551\n87   0  20 105    1     1   0  0  0   1 2557\n88   0  21 108    1     1   0  0  1   2 2594\n89   0  18 107    1     1   0  0  1   0 2600\n91   0  21 124    3     0   0  0  0   0 2622\n\n\nAz oszlopok és a sorok is elnevezhetőek:\n\nstr( birthwt )\n\n'data.frame':   189 obs. of  10 variables:\n $ low  : int  0 0 0 0 0 0 0 0 0 0 ...\n $ age  : int  19 33 20 21 18 21 22 17 29 26 ...\n $ lwt  : int  182 155 105 108 107 124 118 103 123 113 ...\n $ race : int  2 3 1 1 1 3 1 3 1 1 ...\n $ smoke: int  0 0 1 1 1 0 0 0 1 1 ...\n $ ptl  : int  0 0 0 0 0 0 0 0 0 0 ...\n $ ht   : int  0 0 0 0 0 0 0 0 0 0 ...\n $ ui   : int  1 0 0 1 1 0 0 0 0 0 ...\n $ ftv  : int  0 3 1 2 0 0 1 1 1 0 ...\n $ bwt  : int  2523 2551 2557 2594 2600 2622 2637 2637 2663 2665 ...\n\nnames( birthwt )\n\n [1] \"low\"   \"age\"   \"lwt\"   \"race\"  \"smoke\" \"ptl\"   \"ht\"    \"ui\"    \"ftv\"  \n[10] \"bwt\"  \n\ncolnames( birthwt )\n\n [1] \"low\"   \"age\"   \"lwt\"   \"race\"  \"smoke\" \"ptl\"   \"ht\"    \"ui\"    \"ftv\"  \n[10] \"bwt\"  \n\n\nAz adatkeret a mátrixhoz hasonlóan indexelhető:\n\nbirthwt[ 3, ]\n\n   low age lwt race smoke ptl ht ui ftv  bwt\n87   0  20 105    1     1   0  0  0   1 2557\n\nbirthwt[ 3, 4 ]\n\n[1] 1\n\nbirthwt[ 3, c( 5, 6 ) ]\n\n   smoke ptl\n87     1   0\n\n\nSőt, ha vannak elnevezéseink, az is használható. A következő 4 mind egyenértékű:\n\nbirthwt[ , 10  ]\n\n  [1] 2523 2551 2557 2594 2600 2622 2637 2637 2663 2665 2722 2733 2751 2750 2769\n [16] 2769 2778 2782 2807 2821 2835 2835 2836 2863 2877 2877 2906 2920 2920 2920\n [31] 2920 2948 2948 2977 2977 2977 2977 2922 3005 3033 3042 3062 3062 3062 3062\n [46] 3062 3080 3090 3090 3090 3100 3104 3132 3147 3175 3175 3203 3203 3203 3225\n [61] 3225 3232 3232 3234 3260 3274 3274 3303 3317 3317 3317 3321 3331 3374 3374\n [76] 3402 3416 3430 3444 3459 3460 3473 3544 3487 3544 3572 3572 3586 3600 3614\n [91] 3614 3629 3629 3637 3643 3651 3651 3651 3651 3699 3728 3756 3770 3770 3770\n[106] 3790 3799 3827 3856 3860 3860 3884 3884 3912 3940 3941 3941 3969 3983 3997\n[121] 3997 4054 4054 4111 4153 4167 4174 4238 4593 4990  709 1021 1135 1330 1474\n[136] 1588 1588 1701 1729 1790 1818 1885 1893 1899 1928 1928 1928 1936 1970 2055\n[151] 2055 2082 2084 2084 2100 2125 2126 2187 2187 2211 2225 2240 2240 2282 2296\n[166] 2296 2301 2325 2353 2353 2367 2381 2381 2381 2410 2410 2410 2414 2424 2438\n[181] 2442 2450 2466 2466 2466 2495 2495 2495 2495\n\nbirthwt$bwt\n\n  [1] 2523 2551 2557 2594 2600 2622 2637 2637 2663 2665 2722 2733 2751 2750 2769\n [16] 2769 2778 2782 2807 2821 2835 2835 2836 2863 2877 2877 2906 2920 2920 2920\n [31] 2920 2948 2948 2977 2977 2977 2977 2922 3005 3033 3042 3062 3062 3062 3062\n [46] 3062 3080 3090 3090 3090 3100 3104 3132 3147 3175 3175 3203 3203 3203 3225\n [61] 3225 3232 3232 3234 3260 3274 3274 3303 3317 3317 3317 3321 3331 3374 3374\n [76] 3402 3416 3430 3444 3459 3460 3473 3544 3487 3544 3572 3572 3586 3600 3614\n [91] 3614 3629 3629 3637 3643 3651 3651 3651 3651 3699 3728 3756 3770 3770 3770\n[106] 3790 3799 3827 3856 3860 3860 3884 3884 3912 3940 3941 3941 3969 3983 3997\n[121] 3997 4054 4054 4111 4153 4167 4174 4238 4593 4990  709 1021 1135 1330 1474\n[136] 1588 1588 1701 1729 1790 1818 1885 1893 1899 1928 1928 1928 1936 1970 2055\n[151] 2055 2082 2084 2084 2100 2125 2126 2187 2187 2211 2225 2240 2240 2282 2296\n[166] 2296 2301 2325 2353 2353 2367 2381 2381 2381 2410 2410 2410 2414 2424 2438\n[181] 2442 2450 2466 2466 2466 2495 2495 2495 2495\n\nbirthwt[ , \"bwt\" ]\n\n  [1] 2523 2551 2557 2594 2600 2622 2637 2637 2663 2665 2722 2733 2751 2750 2769\n [16] 2769 2778 2782 2807 2821 2835 2835 2836 2863 2877 2877 2906 2920 2920 2920\n [31] 2920 2948 2948 2977 2977 2977 2977 2922 3005 3033 3042 3062 3062 3062 3062\n [46] 3062 3080 3090 3090 3090 3100 3104 3132 3147 3175 3175 3203 3203 3203 3225\n [61] 3225 3232 3232 3234 3260 3274 3274 3303 3317 3317 3317 3321 3331 3374 3374\n [76] 3402 3416 3430 3444 3459 3460 3473 3544 3487 3544 3572 3572 3586 3600 3614\n [91] 3614 3629 3629 3637 3643 3651 3651 3651 3651 3699 3728 3756 3770 3770 3770\n[106] 3790 3799 3827 3856 3860 3860 3884 3884 3912 3940 3941 3941 3969 3983 3997\n[121] 3997 4054 4054 4111 4153 4167 4174 4238 4593 4990  709 1021 1135 1330 1474\n[136] 1588 1588 1701 1729 1790 1818 1885 1893 1899 1928 1928 1928 1936 1970 2055\n[151] 2055 2082 2084 2084 2100 2125 2126 2187 2187 2211 2225 2240 2240 2282 2296\n[166] 2296 2301 2325 2353 2353 2367 2381 2381 2381 2410 2410 2410 2414 2424 2438\n[181] 2442 2450 2466 2466 2466 2495 2495 2495 2495\n\nbirthwt[[ \"bwt\" ]]\n\n  [1] 2523 2551 2557 2594 2600 2622 2637 2637 2663 2665 2722 2733 2751 2750 2769\n [16] 2769 2778 2782 2807 2821 2835 2835 2836 2863 2877 2877 2906 2920 2920 2920\n [31] 2920 2948 2948 2977 2977 2977 2977 2922 3005 3033 3042 3062 3062 3062 3062\n [46] 3062 3080 3090 3090 3090 3100 3104 3132 3147 3175 3175 3203 3203 3203 3225\n [61] 3225 3232 3232 3234 3260 3274 3274 3303 3317 3317 3317 3321 3331 3374 3374\n [76] 3402 3416 3430 3444 3459 3460 3473 3544 3487 3544 3572 3572 3586 3600 3614\n [91] 3614 3629 3629 3637 3643 3651 3651 3651 3651 3699 3728 3756 3770 3770 3770\n[106] 3790 3799 3827 3856 3860 3860 3884 3884 3912 3940 3941 3941 3969 3983 3997\n[121] 3997 4054 4054 4111 4153 4167 4174 4238 4593 4990  709 1021 1135 1330 1474\n[136] 1588 1588 1701 1729 1790 1818 1885 1893 1899 1928 1928 1928 1936 1970 2055\n[151] 2055 2082 2084 2084 2100 2125 2126 2187 2187 2211 2225 2240 2240 2282 2296\n[166] 2296 2301 2325 2353 2353 2367 2381 2381 2381 2410 2410 2410 2414 2424 2438\n[181] 2442 2450 2466 2466 2466 2495 2495 2495 2495\n\n\nA nem dupla szögletes zárójellel történő indexelés eltérése, hogy nem a kiválasztott vektort, hanem egy csak a kiválasztott vektorból álló data frame-et ad vissza:\n\nbirthwt[[ \"bwt\" ]]\n\n  [1] 2523 2551 2557 2594 2600 2622 2637 2637 2663 2665 2722 2733 2751 2750 2769\n [16] 2769 2778 2782 2807 2821 2835 2835 2836 2863 2877 2877 2906 2920 2920 2920\n [31] 2920 2948 2948 2977 2977 2977 2977 2922 3005 3033 3042 3062 3062 3062 3062\n [46] 3062 3080 3090 3090 3090 3100 3104 3132 3147 3175 3175 3203 3203 3203 3225\n [61] 3225 3232 3232 3234 3260 3274 3274 3303 3317 3317 3317 3321 3331 3374 3374\n [76] 3402 3416 3430 3444 3459 3460 3473 3544 3487 3544 3572 3572 3586 3600 3614\n [91] 3614 3629 3629 3637 3643 3651 3651 3651 3651 3699 3728 3756 3770 3770 3770\n[106] 3790 3799 3827 3856 3860 3860 3884 3884 3912 3940 3941 3941 3969 3983 3997\n[121] 3997 4054 4054 4111 4153 4167 4174 4238 4593 4990  709 1021 1135 1330 1474\n[136] 1588 1588 1701 1729 1790 1818 1885 1893 1899 1928 1928 1928 1936 1970 2055\n[151] 2055 2082 2084 2084 2100 2125 2126 2187 2187 2211 2225 2240 2240 2282 2296\n[166] 2296 2301 2325 2353 2353 2367 2381 2381 2381 2410 2410 2410 2414 2424 2438\n[181] 2442 2450 2466 2466 2466 2495 2495 2495 2495\n\nstr( birthwt[[ \"bwt\" ]] )\n\n int [1:189] 2523 2551 2557 2594 2600 2622 2637 2637 2663 2665 ...\n\nhead( birthwt[ \"bwt\" ] )\n\n    bwt\n85 2523\n86 2551\n87 2557\n88 2594\n89 2600\n91 2622\n\nstr( birthwt[ \"bwt\" ] )\n\n'data.frame':   189 obs. of  1 variable:\n $ bwt: int  2523 2551 2557 2594 2600 2622 2637 2637 2663 2665 ...\n\n\nHasználhatunk különféle módszereket (az alábbiak közül a második a logikai indexelés miatt fog működni):\n\nhead( birthwt[ , c( \"lwt\", \"smoke\" ) ] )\n\n   lwt smoke\n85 182     0\n86 155     0\n87 105     1\n88 108     1\n89 107     1\n91 124     0\n\nhead( birthwt[ birthwt$smoke==1, ] )\n\n    low age lwt race smoke ptl ht ui ftv  bwt\n87    0  20 105    1     1   0  0  0   1 2557\n88    0  21 108    1     1   0  0  1   2 2594\n89    0  18 107    1     1   0  0  1   0 2600\n94    0  29 123    1     1   0  0  0   1 2663\n95    0  26 113    1     1   0  0  0   0 2665\n100   0  18 100    1     1   0  0  0   0 2769\n\nhead( birthwt[ birthwt$smoke==1&birthwt$race==1, ] )\n\n    low age lwt race smoke ptl ht ui ftv  bwt\n87    0  20 105    1     1   0  0  0   1 2557\n88    0  21 108    1     1   0  0  1   2 2594\n89    0  18 107    1     1   0  0  1   0 2600\n94    0  29 123    1     1   0  0  0   1 2663\n95    0  26 113    1     1   0  0  0   0 2665\n100   0  18 100    1     1   0  0  0   0 2769\n\n\nAz adatkeret heterogén:\n\nbirthwt$nev &lt;- \"a\"\nhead( birthwt )\n\n   low age lwt race smoke ptl ht ui ftv  bwt nev\n85   0  19 182    2     0   0  0  1   0 2523   a\n86   0  33 155    3     0   0  0  0   3 2551   a\n87   0  20 105    1     1   0  0  0   1 2557   a\n88   0  21 108    1     1   0  0  1   2 2594   a\n89   0  18 107    1     1   0  0  1   0 2600   a\n91   0  21 124    3     0   0  0  0   0 2622   a\n\nstr( birthwt )\n\n'data.frame':   189 obs. of  11 variables:\n $ low  : int  0 0 0 0 0 0 0 0 0 0 ...\n $ age  : int  19 33 20 21 18 21 22 17 29 26 ...\n $ lwt  : int  182 155 105 108 107 124 118 103 123 113 ...\n $ race : int  2 3 1 1 1 3 1 3 1 1 ...\n $ smoke: int  0 0 1 1 1 0 0 0 1 1 ...\n $ ptl  : int  0 0 0 0 0 0 0 0 0 0 ...\n $ ht   : int  0 0 0 0 0 0 0 0 0 0 ...\n $ ui   : int  1 0 0 1 1 0 0 0 0 0 ...\n $ ftv  : int  0 3 1 2 0 0 1 1 1 0 ...\n $ bwt  : int  2523 2551 2557 2594 2600 2622 2637 2637 2663 2665 ...\n $ nev  : chr  \"a\" \"a\" \"a\" \"a\" ...\n\n\n\n\n2.3.5 Lista\nA lista heterogén, egydimenziós adatszerkezet.\nLegegyszerűbben elemei felsorolásával hozható létre, a list függvényt használva:\n\nlista &lt;- list( sz = szamvektor, k = karaktervektor, m = szammatrix, df = birthwt[ 1:5, ] )\nlista\n\n$sz\n  egy ketto harom                                           \n    4     1    99    NA    NA    NA    NA    NA    NA   999 \n\n$k\n[1] \"a\"   \"b\"   \"xyz\"\n\n$m\n     [,1] [,2]\n[1,]    1    4\n[2,]    2    5\n[3,]    3    6\n\n$df\n   low age lwt race smoke ptl ht ui ftv  bwt nev\n85   0  19 182    2     0   0  0  1   0 2523   a\n86   0  33 155    3     0   0  0  0   3 2551   a\n87   0  20 105    1     1   0  0  0   1 2557   a\n88   0  21 108    1     1   0  0  1   2 2594   a\n89   0  18 107    1     1   0  0  1   0 2600   a\n\nstr( lista )\n\nList of 4\n $ sz: Named num [1:10] 4 1 99 NA NA NA NA NA NA 999\n  ..- attr(*, \"names\")= chr [1:10] \"egy\" \"ketto\" \"harom\" \"\" ...\n $ k : chr [1:3] \"a\" \"b\" \"xyz\"\n $ m : int [1:3, 1:2] 1 2 3 4 5 6\n $ df:'data.frame': 5 obs. of  11 variables:\n  ..$ low  : int [1:5] 0 0 0 0 0\n  ..$ age  : int [1:5] 19 33 20 21 18\n  ..$ lwt  : int [1:5] 182 155 105 108 107\n  ..$ race : int [1:5] 2 3 1 1 1\n  ..$ smoke: int [1:5] 0 0 1 1 1\n  ..$ ptl  : int [1:5] 0 0 0 0 0\n  ..$ ht   : int [1:5] 0 0 0 0 0\n  ..$ ui   : int [1:5] 1 0 0 1 1\n  ..$ ftv  : int [1:5] 0 3 1 2 0\n  ..$ bwt  : int [1:5] 2523 2551 2557 2594 2600\n  ..$ nev  : chr [1:5] \"a\" \"a\" \"a\" \"a\" ...\n\n\nSzámmal és – ha van neki – névvel is indexelhető:\n\nlista[[ 1 ]]\n\n  egy ketto harom                                           \n    4     1    99    NA    NA    NA    NA    NA    NA   999 \n\nlista$sz\n\n  egy ketto harom                                           \n    4     1    99    NA    NA    NA    NA    NA    NA   999 \n\nlista[[ \"sz\" ]]\n\n  egy ketto harom                                           \n    4     1    99    NA    NA    NA    NA    NA    NA   999 \n\n\nAz egy zárójellel történő indexelés látszólag ugyanaz, de csak látszólag:\n\nlista[ 1 ]\n\n$sz\n  egy ketto harom                                           \n    4     1    99    NA    NA    NA    NA    NA    NA   999 \n\ntypeof( lista[[ 1 ]] )\n\n[1] \"double\"\n\ntypeof( lista[ 1 ] )\n\n[1] \"list\"\n\n\nTartomány is indexelhető:\n\nlista[ 1:2 ]\n\n$sz\n  egy ketto harom                                           \n    4     1    99    NA    NA    NA    NA    NA    NA   999 \n\n$k\n[1] \"a\"   \"b\"   \"xyz\"\n\nlista[[ 1:2 ]]\n\n[1] 1\n\n\nAz előbbi dolgok természetesen kombinálhatóak is:\n\nidx &lt;- \"sz\"\nlista[[ idx ]]\n\n  egy ketto harom                                           \n    4     1    99    NA    NA    NA    NA    NA    NA   999 \n\n\nAz adatkeret igazából egy, az oszlopokból - mint vektorokból - összerakott lista (tehát két szűkítés van: az elemek csak vektorok lehetnek és ugyanolyan hosszúaknak kell lenniük).",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Adattípusok, adatszerkezetek</span>"
    ]
  },
  {
    "objectID": "fuggvenyek.html",
    "href": "fuggvenyek.html",
    "title": "3  Függvények",
    "section": "",
    "text": "3.1 Függvényhívások\nFüggvény úgy hívható, hogy megadjuk a nevét, majd utána zárójelben az argumentumát, vagy argumentumait (lehet, hogy egy sincs, de a zárójelet ekkor is ki kell írni):\nquantile( birthwt$bwt )\n\n  0%  25%  50%  75% 100% \n 709 2414 2977 3487 4990\nFüggvényről súgó a kérdőjellel kapható (két kérdőjel az összes ismert függvényt végigkeresi, akár névtöredékre is): ?quantile.\nAminél egyenlőségjellel adva van érték a specifikációban, ott az default-ként viselkedik, nem kötelező megadni, viszont a default-tal nem rendelkezőket muszáj:\nquantile()\n\nError in quantile.default(): argument \"x\" is missing, with no default\nHa több argumentumot adunk meg, akkor azok a felsorolás sorrendjében osztódnak ki:\nquantile( birthwt$bwt, 0.23 )\n\n    23% \n2387.96 \n\nquantile( birthwt$bwt, c( 0.23, 0.5, 0.6 ) )\n\n    23%     50%     60% \n2387.96 2977.00 3169.40\nArgumentumra hivatkozhatunk névvel is, ez esetben nem kell a felsorolás sorrendjével törődnünk:\nquantile( birthwt$bwt, c( 0.23, 0.5, 0.6 ), type = 6 )\n\n 23%  50%  60% \n2381 2977 3175 \n\nquantile( probs = c( 0.23, 0.5, 0.6 ), type = 6, x = birthwt$bwt )\n\n 23%  50%  60% \n2381 2977 3175\nAz általános gyakorlat az, hogy az első két-három argumentumot adhatjuk meg név nélkül (ezeknél elvárható, hogy fejből is tudja az ember, hogy mit jelent), de a többinél elegánsabb, ha mindenképp adunk nevet (tehát akkor is, ha sorrendben írjuk).\nEgy függvény hívásánál az argumentumai elkülöníthetőek egy listába, majd ugyanaz a hatása a do.call használatával elérhető (első argumentum a függvény, második az átadandó argumentumok listája):\nquantile( probs = c( 0.23, 0.5, 0.6 ), type = 6, x = birthwt$bwt )\n\n 23%  50%  60% \n2381 2977 3175 \n\ndo.call( quantile, list( probs = c( 0.23, 0.5, 0.6 ), type = 6, x = birthwt$bwt ) )\n\n 23%  50%  60% \n2381 2977 3175\nEz akkor jön jól, ha nem tudjuk előre, hogy mik az argumentumok (akár azt sem, hogy hány darab van belőlük!), pl. mert egy lapply-jal gyártottuk le, lásd később:\nrbind( c( 1, 2 ), c( 3, 4 ), c( 5, 6 ) )\n\n     [,1] [,2]\n[1,]    1    2\n[2,]    3    4\n[3,]    5    6\n\ndo.call( rbind, lapply( birthwt, function( x ) c( mean( x ), median( x ) ) ) )\n\n              [,1] [,2]\nlow   3.121693e-01    0\nage   2.323810e+01   23\nlwt   1.298148e+02  121\nrace  1.846561e+00    1\nsmoke 3.915344e-01    0\nptl   1.957672e-01    0\nht    6.349206e-02    0\nui    1.481481e-01    0\nftv   7.936508e-01    0\nbwt   2.944587e+03 2977",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Függvények</span>"
    ]
  },
  {
    "objectID": "fuggvenyek.html#saját-függény-definiálása",
    "href": "fuggvenyek.html#saját-függény-definiálása",
    "title": "3  Függvények",
    "section": "3.2 Saját függény definiálása",
    "text": "3.2 Saját függény definiálása\nIlyet is lehet.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Függvények</span>"
    ]
  },
  {
    "objectID": "programozas.html",
    "href": "programozas.html",
    "title": "4  Az R programozása",
    "section": "",
    "text": "4.1 Funkcionális programozás\nAz R, bár többféle paradigmában is tud dolgozni, érezhető funkcionális nyelv. Ezt elegáns is, célszerű is kihasználni!\nEgy példa:\nmean( birthwt$bwt[ 1:100 ] )\n\n[1] 3130.16\n\nelsoszazatlag &lt;- function( data ) {\n  result &lt;- mean( data[ 1:100 ] )\n  return( result )\n}\n\nelsoszazatlag &lt;- function( data ) {\n  result &lt;- mean( data[ 1:100 ] )\n  result\n}\nelsoszazatlag &lt;- function( data ) {\n  mean( data[ 1:100 ] )\n}\n\nelsoszazatlag( birthwt$bwt )\n\n[1] 3130.16\n\nsd( birthwt$bwt[ 1:100 ] )\n\n[1] 323.7243\n\nelsoszazf &lt;- function( data, f = mean ) {\n  f( data[ 1:100 ] )\n}\nelsoszazf( birthwt$bwt )\n\n[1] 3130.16\n\nelsoszazf( birthwt$bwt, f = sd )\n\n[1] 323.7243\nA lapply az első argumentumban megadott lista minden elemére ráereszti a második argumentumban megadott függvényt, és az eredményt összefűzi egy listává (a sapply csak annyiban tér el, hogy lista helyett vektort ad vissza, ha lehetséges a listát vektorrá konvertálni):\nlapply( c( \"age\", \"lwt\", \"bwt\" ), nchar )\n\n[[1]]\n[1] 3\n\n[[2]]\n[1] 3\n\n[[3]]\n[1] 3\n\nsapply( c( \"age\", \"lwt\", \"bwt\" ), nchar )\n\nage lwt bwt \n  3   3   3 \n\nlapply( c( \"age\", \"lwt\", \"bwt\" ), function( x ) nchar( x ) )\n\n[[1]]\n[1] 3\n\n[[2]]\n[1] 3\n\n[[3]]\n[1] 3\n\nlapply( c( \"age\", \"lwt\", \"bwt\" ), function( x ) mean( birthwt[[ x ]] ) )\n\n[[1]]\n[1] 23.2381\n\n[[2]]\n[1] 129.8148\n\n[[3]]\n[1] 2944.587\n\nsapply( c( \"age\", \"lwt\", \"bwt\" ), function( x ) mean( birthwt[[ x ]] ) )\n\n      age       lwt       bwt \n  23.2381  129.8148 2944.5873 \n\nsapply( birthwt, mean )\n\n         low          age          lwt         race        smoke          ptl \n3.121693e-01 2.323810e+01 1.298148e+02 1.846561e+00 3.915344e-01 1.957672e-01 \n          ht           ui          ftv          bwt \n6.349206e-02 1.481481e-01 7.936508e-01 2.944587e+03 \n\nlapply( birthwt, function( x ) c( mean( x ), median( x ) ) )\n\n$low\n[1] 0.3121693 0.0000000\n\n$age\n[1] 23.2381 23.0000\n\n$lwt\n[1] 129.8148 121.0000\n\n$race\n[1] 1.846561 1.000000\n\n$smoke\n[1] 0.3915344 0.0000000\n\n$ptl\n[1] 0.1957672 0.0000000\n\n$ht\n[1] 0.06349206 0.00000000\n\n$ui\n[1] 0.1481481 0.0000000\n\n$ftv\n[1] 0.7936508 0.0000000\n\n$bwt\n[1] 2944.587 2977.000\nA harmadik sor példát mutat arra, hogy anonim függvény is használható, az utolsó előtti pedig arra, hogy a data.frame igazából lista, aminek az elemei az oszlopai.\nAz apply az első argumentumban megadott mátrix vagy adatkeret minden sorára vagy oszlopára (ezt a második argumentum dönti el) ráereszti a harmadik argumentumban megadott függvényt:\napply( birthwt, 2, mean )\n\n         low          age          lwt         race        smoke          ptl \n3.121693e-01 2.323810e+01 1.298148e+02 1.846561e+00 3.915344e-01 1.957672e-01 \n          ht           ui          ftv          bwt \n6.349206e-02 1.481481e-01 7.936508e-01 2.944587e+03 \n\napply( birthwt, 1, function( x ) x[ 1 ] )\n\n 85  86  87  88  89  91  92  93  94  95  96  97  98  99 100 101 102 103 104 105 \n  0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0 \n106 107 108 109 111 112 113 114 115 116 117 118 119 120 121 123 124 125 126 127 \n  0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0 \n128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 \n  0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0 \n148 149 150 151 154 155 156 159 160 161 162 163 164 166 167 168 169 170 172 173 \n  0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0 \n174 175 176 177 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 195 \n  0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0 \n196 197 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 \n  0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0 \n217 218 219 220 221 222 223 224 225 226   4  10  11  13  15  16  17  18  19  20 \n  0   0   0   0   0   0   0   0   0   0   1   1   1   1   1   1   1   1   1   1 \n 22  23  24  25  26  27  28  29  30  31  32  33  34  35  36  37  40  42  43  44 \n  1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1 \n 45  46  47  49  50  51  52  54  56  57  59  60  61  62  63  65  67  68  69  71 \n  1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1 \n 75  76  77  78  79  81  82  83  84 \n  1   1   1   1   1   1   1   1   1\nA tapply az első argumentumban megadott változó második argumentum szerint képezett csoportjaira ráereszti a harmadik argumentumban megadott függvényt:\nmean( birthwt$bwt[ birthwt$race==1 ] )\n\n[1] 3102.719\n\ntapply( birthwt$bwt, birthwt$race, mean )\n\n       1        2        3 \n3102.719 2719.692 2805.284",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Az R programozása</span>"
    ]
  },
  {
    "objectID": "datatable.html",
    "href": "datatable.html",
    "title": "5  Data table: egy továbbfejlesztett adatkeret",
    "section": "",
    "text": "5.1 Sebesség és nagyméretű adatbázisok kezelése\nEz a probléma a legtöbb szokásos elemzési feladatnál nem jelentkezik, itt sem fogunk rá részletes példát nézni, de röviden érdemes arról megemlékezni, hogy a hagyományos adatkeret (data frame) adatstuktúra nem szerencsés, ha nagyméretű adatbázisokat kell kezelnünk.\nAz első probléma kapásból az adatok beolvasásánál fog jelentkezni: a read.csv (és társai) egész egyszerűen lassúak. Pár százezer sorig ennek semmilyen érzékelhető hatása nincsen, mert még így is elég gyors a beolvasás, így a legtöbb feladatnál ez a probléma nem jelentkezik, de millió soros, több millió soros adatbázisoknál, ha a tábla mérete több gigabájt vagy több tíz gigabájt, akkor a beolvasás a méret növekedtével gyorsan lassul, míg végül teljesen reménytelenné válik. A data.table definiálja az fread függvényt mely ezzel szemben villámgyors, és még ilyen méretű adatok beolvasásánál is elfogadható sebességet produkál. (Az fread-nek ezen kívül van pár további előnye is az R beépített beolvasó függvényeihez képest, olyan, amik kis méretű adatbázisoknál is érdekesek lehetnek, például nagyon okosan detektálja az oszlopelválasztókat és az oszloptípusokat.) Hasonló a helyzet kiírásnál: a write.csv és társai nagyon nagy adatbázisoknál elfogadhatatlanul lassúak lesznek, de a data.table könyvtár fwrite függvénye ilyenkor is jól működik.\nA második probléma, hogy még ha valahogy be is olvastuk az adatbázist a memóriába, akkor is bajban leszünk az adattranszformációkkal: a data frame nincs túl jól optimalizálva ilyen szempontból, egy sor művelet nagyon lassú. Ismét csak: ennek kis, közepes és a legtöbb terület mércéje szerinti nagy adatbázisoknál nincs jelentősége, mert még így is gyors, de a nagyon nagy adatbázisoknál bajban leszünk data frame-et használva. A data table ezzel szemben nagyon jól optimalizált, képest többmagú processzoroknál bizonyos műveletek párhuzamos végrehajtására is, így az adattranszformációs műveleteknél4 (aggregáció, táblaegyesítések, de akár új változó létrehozása) sokkal jobb sebességet tud produkálni.\nA fentieket többféle benchmark vizsgálat is megerősíti.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Data table: egy továbbfejlesztett adatkeret</span>"
    ]
  },
  {
    "objectID": "datatable.html#jobb-kiíratás",
    "href": "datatable.html#jobb-kiíratás",
    "title": "5  Data table: egy továbbfejlesztett adatkeret",
    "section": "5.2 Jobb kiíratás",
    "text": "5.2 Jobb kiíratás\nA data frame kiíratásánál (tehát ha egyszerűen beírjuk, hogy RawDataDF, ami ekvivalens a print(RawDataDF) függvény meghívásával) az alapbeállítás az, hogy kiírja a konzolra az első jó sok sorát az adatbázisnak5. Ez nem túl praktikus: az 587. sor ismerete jellemzően nem sokat ad hozzá az első 586-hoz, cserében hosszasan kell görgetnünk a rengeteg sor miatt, hogy elérjünk a kiíratás tetejére, aminek viszont volna jelentősége, mert ott látjuk az oszlopok neveit. (Nem véletlenül gyakori, hogy sokan eleve a head(RawDataDF) típusú kéréssel íratják ki a data frame-eket!)\nA data table alapértelmezett kiíratása okosabb, mert csak az első néhány és az utolsó néhány sort6 írja ki:\n\nRawData\n\nKey: &lt;County, Sex, Age, Year&gt;\n                County    Sex   Age  Year ICDCode     N Population\n                &lt;char&gt; &lt;char&gt; &lt;num&gt; &lt;num&gt;  &lt;char&gt; &lt;int&gt;      &lt;num&gt;\n      1: Baranya megye  Férfi     0  2000     C00     0     9876.0\n      2: Baranya megye  Férfi     0  2000     C01     0     9876.0\n      3: Baranya megye  Férfi     0  2000     C02     0     9876.0\n      4: Baranya megye  Férfi     0  2000     C03     0     9876.0\n      5: Baranya megye  Férfi     0  2000     C04     0     9876.0\n     ---                                                          \n1313276:    Zala megye     Nő    85  2018     D06     0     4483.5\n1313277:    Zala megye     Nő    85  2018     D07     0     4483.5\n1313278:    Zala megye     Nő    85  2018     D09     0     4483.5\n1313279:    Zala megye     Nő    85  2018     D30     0     4483.5\n1313280:    Zala megye     Nő    85  2018     D33     0     4483.5\n\n\nTermészetesen láthatóak az oszlopfejlécek (változónevek) is, sőt, itt van még egy további apró fejlesztés: a data table kiírja az egyes oszlopok adattípusát is, standard rövidítéssel.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Data table: egy továbbfejlesztett adatkeret</span>"
    ]
  },
  {
    "objectID": "datatable.html#kényelmesebb-sorindexelés-sor-szűrés-és--rendezés",
    "href": "datatable.html#kényelmesebb-sorindexelés-sor-szűrés-és--rendezés",
    "title": "5  Data table: egy továbbfejlesztett adatkeret",
    "section": "5.3 Kényelmesebb sorindexelés (sor-szűrés és -rendezés)",
    "text": "5.3 Kényelmesebb sorindexelés (sor-szűrés és -rendezés)\nData frame indexeléséhez szögletes zárójelet kell írnunk a változó neve után, abba vesszőt tennünk, majd a vessző elé kerül az sor indexelése. Ezt tipikusan szűréshez használjuk. Például, ha ki akarjuk választani csak a 2010-es év adatait:\n\nhead(RawDataDF[RawDataDF$Year == 2010,])\n\n           County   Sex Age Year ICDCode N Population\n961 Baranya megye Férfi   0 2010     C00 0       9430\n962 Baranya megye Férfi   0 2010     C01 0       9430\n963 Baranya megye Férfi   0 2010     C02 0       9430\n964 Baranya megye Férfi   0 2010     C03 0       9430\n965 Baranya megye Férfi   0 2010     C04 0       9430\n966 Baranya megye Férfi   0 2010     C05 0       9430\n\n\nEz lényegében a „logikai vektorral indexelés” esete: a RawDataDF$Year == 2010 egy adatbázissal sorainak számával azonos hosszúságú logikai vektor lesz.\nHa ki akarjuk választani 2010 évben a 40 évnél idősebbek adatait, akkor a logikai ÉS operátort (&) kell használnunk; ez egyúttal azt is szemlélteti, hogy a feltételek természetesen nem csak egyenlőségek lehetnek:\n\nhead(RawDataDF[RawDataDF$Year == 2010 & RawDataDF$Age &gt;= 40,])\n\n             County   Sex Age Year ICDCode N Population\n15553 Baranya megye Férfi  40 2010     C00 0      13076\n15554 Baranya megye Férfi  40 2010     C01 0      13076\n15555 Baranya megye Férfi  40 2010     C02 0      13076\n15556 Baranya megye Férfi  40 2010     C03 0      13076\n15557 Baranya megye Férfi  40 2010     C04 0      13076\n15558 Baranya megye Férfi  40 2010     C05 0      13076\n\n\nA dolog hasonlóan folytatódik, ha további feltételek vannak. Például 2010 évben a 40 évnél idősebb budapesti vagy Pest megyei férfiak körében előforduló vastagbélrákos (BNO-kód: C18) esetek kiválasztása:\n\nhead(RawDataDF[RawDataDF$Year == 2010 &  RawDataDF$Age &gt;= 40 &\n                 RawDataDF$County %in% c(\"Budapest\",\n                                         \"Pest megye\") &\n                 RawDataDF$Sex == \"Férfi\" &\n                 RawDataDF$ICDCode == \"C18\",])\n\n         County   Sex Age Year ICDCode   N Population\n146899 Budapest Férfi  40 2010     C18   3    57445.5\n148723 Budapest Férfi  45 2010     C18  10    42410.0\n150547 Budapest Férfi  50 2010     C18  17    45329.0\n152371 Budapest Férfi  55 2010     C18  44    55633.5\n154195 Budapest Férfi  60 2010     C18  59    45170.0\n156019 Budapest Férfi  65 2010     C18 120    39588.0\n\n\nA dolog tökéletesen működik, ámde nem túl kényelmes: folyton be kell írni a RawDataDF$-t a feltételek közé. A kód hosszú, lassabb megírni, és az olvashatóság is romlik. Fontos hangsúlyozni, hogy ez nem hagyható el, és teljesen igaza is van az R-nek, hogy nem hagyható el: Year nevű változó nem létezik, tehát teljes joggal ad hibát, ha előle – vagy bármelyik másik elől – elhagyjuk a data frame nevét.\nMégis: a gyakorlatban az esetek 99,99%-ában, ha egy változó nevére hivatkozunk miközben egy adatkeret sorindexelését végezzük, akkor azt természetesen úgy értjük, hogy annak az adatkeretnek az adott nevű oszlopa (és nem egy külső változó). Éppen emiatt a data table megengedi ezt a szintaktikát: ha pusztán egy változó nevére hivatkozunk, akkor ő megnézi, hogy nincs-e olyan nevű oszlopa az indexelt adattáblának, és ha van, akkor úgy veszi, hogy arra szerettünk volna hivatkozni. Éppen ezért az alábbi kód data.frame-mel nem, de data.table-lel működik:\n\nRawData[Year == 2010 & Age &gt;= 40 &\n          County %in% c(\"Budapest\", \"Pest megye\") &\n          Sex == \"Férfi\" & ICDCode == \"C18\",]\n\nKey: &lt;County, Sex, Age, Year&gt;\n        County    Sex   Age  Year ICDCode     N Population\n        &lt;char&gt; &lt;char&gt; &lt;num&gt; &lt;num&gt;  &lt;char&gt; &lt;int&gt;      &lt;num&gt;\n 1:   Budapest  Férfi    40  2010     C18     3    57445.5\n 2:   Budapest  Férfi    45  2010     C18    10    42410.0\n 3:   Budapest  Férfi    50  2010     C18    17    45329.0\n 4:   Budapest  Férfi    55  2010     C18    44    55633.5\n 5:   Budapest  Férfi    60  2010     C18    59    45170.0\n 6:   Budapest  Férfi    65  2010     C18   120    39588.0\n 7:   Budapest  Férfi    70  2010     C18    80    27335.5\n 8:   Budapest  Férfi    75  2010     C18    75    22253.5\n 9:   Budapest  Férfi    80  2010     C18    72    15775.5\n10:   Budapest  Férfi    85  2010     C18    35    10922.0\n11: Pest megye  Férfi    40  2010     C18     8    48086.0\n12: Pest megye  Férfi    45  2010     C18     6    36113.5\n13: Pest megye  Férfi    50  2010     C18    14    37167.0\n14: Pest megye  Férfi    55  2010     C18    32    41154.0\n15: Pest megye  Férfi    60  2010     C18    43    32527.0\n16: Pest megye  Férfi    65  2010     C18    56    26071.0\n17: Pest megye  Férfi    70  2010     C18    62    16926.5\n18: Pest megye  Férfi    75  2010     C18    45    11964.5\n19: Pest megye  Férfi    80  2010     C18    23     7015.0\n20: Pest megye  Férfi    85  2010     C18    11     4250.5\n        County    Sex   Age  Year ICDCode     N Population\n\n\nA kapott kód világosabb, gyorsabban beírható és jobban olvasható!\nA data table azt is megengedi, hogy a vesszőt elhagyjuk (a data frame nem, ott hibát adna ha nem írnánk vesszőt!):\n\nRawData[Year == 2010 & Age &gt;= 40 &\n          County %in% c(\"Budapest\", \"Pest megye\") &\n          Sex == \"Férfi\" & ICDCode == \"C18\"]\n\nKey: &lt;County, Sex, Age, Year&gt;\n        County    Sex   Age  Year ICDCode     N Population\n        &lt;char&gt; &lt;char&gt; &lt;num&gt; &lt;num&gt;  &lt;char&gt; &lt;int&gt;      &lt;num&gt;\n 1:   Budapest  Férfi    40  2010     C18     3    57445.5\n 2:   Budapest  Férfi    45  2010     C18    10    42410.0\n 3:   Budapest  Férfi    50  2010     C18    17    45329.0\n 4:   Budapest  Férfi    55  2010     C18    44    55633.5\n 5:   Budapest  Férfi    60  2010     C18    59    45170.0\n 6:   Budapest  Férfi    65  2010     C18   120    39588.0\n 7:   Budapest  Férfi    70  2010     C18    80    27335.5\n 8:   Budapest  Férfi    75  2010     C18    75    22253.5\n 9:   Budapest  Férfi    80  2010     C18    72    15775.5\n10:   Budapest  Férfi    85  2010     C18    35    10922.0\n11: Pest megye  Férfi    40  2010     C18     8    48086.0\n12: Pest megye  Férfi    45  2010     C18     6    36113.5\n13: Pest megye  Férfi    50  2010     C18    14    37167.0\n14: Pest megye  Férfi    55  2010     C18    32    41154.0\n15: Pest megye  Férfi    60  2010     C18    43    32527.0\n16: Pest megye  Férfi    65  2010     C18    56    26071.0\n17: Pest megye  Férfi    70  2010     C18    62    16926.5\n18: Pest megye  Férfi    75  2010     C18    45    11964.5\n19: Pest megye  Férfi    80  2010     C18    23     7015.0\n20: Pest megye  Férfi    85  2010     C18    11     4250.5\n        County    Sex   Age  Year ICDCode     N Population\n\n\nFontos azonban, hogy ez csak ebben az esetben, tehát sorindexelésnél használható: ha nincs vessző, akkor automatikusan úgy veszi, hogy amit beírtunk, az sorindex (e megállapodás nélkül nem tudhatná, hogy mit akartunk indexelni).\nA tény, hogy nem kell hivatkozni az adatkeret nevére, nem csak szűrésnél igaz, hanem rendezésnél is. Ezt ugyanis az order függvény valósítja meg, ami elérhető volt a data frame-hez is, csak ott ilyen módon kellett használnunk:\n\nhead(RawDataDF[order(RawDataDF$N),])\n\n         County   Sex Age Year ICDCode N Population\n1 Baranya megye Férfi   0 2000     C00 0       9876\n2 Baranya megye Férfi   0 2000     C01 0       9876\n3 Baranya megye Férfi   0 2000     C02 0       9876\n4 Baranya megye Férfi   0 2000     C03 0       9876\n5 Baranya megye Férfi   0 2000     C04 0       9876\n6 Baranya megye Férfi   0 2000     C05 0       9876\n\n\nA data table azonban itt is megengedi7 a fenti – nagyon logikus – egyszerűsítést:\n\nRawData[order(N),]\n\n                County    Sex   Age  Year ICDCode     N Population\n                &lt;char&gt; &lt;char&gt; &lt;num&gt; &lt;num&gt;  &lt;char&gt; &lt;int&gt;      &lt;num&gt;\n      1: Baranya megye  Férfi     0  2000     C00     0     9876.0\n      2: Baranya megye  Férfi     0  2000     C01     0     9876.0\n      3: Baranya megye  Férfi     0  2000     C02     0     9876.0\n      4: Baranya megye  Férfi     0  2000     C03     0     9876.0\n      5: Baranya megye  Férfi     0  2000     C04     0     9876.0\n     ---                                                          \n1313276:      Budapest     Nő    60  2008     C50   307    64674.0\n1313277:      Budapest     Nő    55  2000     C50   308    67218.5\n1313278:      Budapest     Nő    55  2002     C50   308    69118.0\n1313279:      Budapest     Nő    70  2018     C44   331    56508.0\n1313280:      Budapest     Nő    55  2003     C50   350    69396.5\n\n\nTermészetesen a „szűrés” és „rendezés” csak felhasználói szempontból két külön művelet. Az R számára a kettő ugyanaz: sorindexelés, csak annyi eltéréssel, hogy az előbbi esetben logikai vektort kap, az utóbbiban pedig számvektort (hiszen az order egyszerűen megadja sorban minden elemre, hogy az adott elem hányadik a nagyság szerinti sorrendben).",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Data table: egy továbbfejlesztett adatkeret</span>"
    ]
  },
  {
    "objectID": "datatable.html#kibővített-oszlopindexelés-oszlop-kiválasztás-és-oszlop-létrehozás-műveletekkel",
    "href": "datatable.html#kibővített-oszlopindexelés-oszlop-kiválasztás-és-oszlop-létrehozás-műveletekkel",
    "title": "5  Data table: egy továbbfejlesztett adatkeret",
    "section": "5.4 Kibővített oszlopindexelés: oszlop-kiválasztás és oszlop-létrehozás műveletekkel",
    "text": "5.4 Kibővített oszlopindexelés: oszlop-kiválasztás és oszlop-létrehozás műveletekkel\nHagyományos data frame esetén a vessző után jön az oszlopindexelés, ami egy dolgot jelenthet: oszlopok kiválasztását. Tehát, dönthetünk, hogy mely oszlopokat kérjük (és melyeket nem), de más lehetőségünk nincs. Oszlopok kiválasztását célszerű mindig névvel és nem számmal végeznünk (hogy a kód az adatbázis esetleges későbbi módosításaira robusztusabb legyen, ne romoljon el új oszlop beszúrásától vagy törlésétől, valamint, hogy önállóan is jobban olvasható legyen a kód). Ekkor lényegében egy sztring-vektort kell átadnunk. A példa kedvéért itt – az előzőekkel szemben – a 40-45 éves budapesti férfiak vastagbélrákos eseteire szorítsuk meg magunkat, viszont tartsuk meg az összes évet. Ez esetben logikus csak az évet – és persze az N-et és a Population-t – kiíratni, hiszen a többi konstans:\n\nhead(RawDataDF[RawDataDF$Age == 40 &\n                 RawDataDF$County == \"Budapest\" &\n                 RawDataDF$Sex == \"Férfi\" &\n                 RawDataDF$ICDCode == \"C18\",\n               c(\"Year\", \"N\", \"Population\")])\n\n       Year N Population\n145939 2000 8    51602.0\n146035 2001 4    47836.0\n146131 2002 4    45296.5\n146227 2003 4    43632.5\n146323 2004 4    43085.0\n146419 2005 5    43442.5\n\n\nEz a szintaktika a data.table-lel is működik8:\n\nRawData[Age == 40 & County == \"Budapest\" & Sex == \"Férfi\" &\n          ICDCode == \"C18\",\n        c(\"Year\", \"N\", \"Population\")]\n\n     Year     N Population\n    &lt;num&gt; &lt;int&gt;      &lt;num&gt;\n 1:  2000     8    51602.0\n 2:  2001     4    47836.0\n 3:  2002     4    45296.5\n 4:  2003     4    43632.5\n 5:  2004     4    43085.0\n 6:  2005     5    43442.5\n 7:  2006     5    44511.5\n 8:  2007     6    46903.5\n 9:  2008     4    50505.5\n10:  2009     6    54015.0\n11:  2010     3    57445.5\n12:  2011     8    60721.0\n13:  2012     7    62471.5\n14:  2013     5    63746.5\n15:  2014     8    66250.5\n16:  2015    13    70511.5\n17:  2016    11    74622.0\n18:  2017     6    77902.0\n19:  2018    10    80555.0\n\n\nA data.table-nek van azonban egy saját, külön szintaktikája erre, és célszerű is azt megszokni és használni mindig, mert a későbbi funkciókat az teszi elérhetővé:\n\nRawData[Age == 40 & County == \"Budapest\" & Sex == \"Férfi\" &\n          ICDCode == \"C18\",\n        .(Year, N, Population)]\n\n     Year     N Population\n    &lt;num&gt; &lt;int&gt;      &lt;num&gt;\n 1:  2000     8    51602.0\n 2:  2001     4    47836.0\n 3:  2002     4    45296.5\n 4:  2003     4    43632.5\n 5:  2004     4    43085.0\n 6:  2005     5    43442.5\n 7:  2006     5    44511.5\n 8:  2007     6    46903.5\n 9:  2008     4    50505.5\n10:  2009     6    54015.0\n11:  2010     3    57445.5\n12:  2011     8    60721.0\n13:  2012     7    62471.5\n14:  2013     5    63746.5\n15:  2014     8    66250.5\n16:  2015    13    70511.5\n17:  2016    11    74622.0\n18:  2017     6    77902.0\n19:  2018    10    80555.0\n\n\nMegjegyzendő, hogy a . egyszerűen egy rövidítés, amit a data.table csomag bevezet arra, hogy list, magyarán itt az történik, hogy egy listát kell átadnunk9, benne az – idézőjelek nélküli – oszlopnevekkel. A listás megoldás előnye, hogy valójában nem kötelező explicite kiírni, hogy . majd felsorolni a változóneveket zárójelben, bármilyen függvényt is használhatunk a vessző után ami listát ad eredményül. Később látunk majd erre példát.\nAz is érthető a listás megoldás fényében, hogy data table-lel átnevezhetünk változót úgymond „menet közben” (data frame-mel már ezt sem lehetett!):\n\nRawData[Age == 40 & County == \"Budapest\" & Sex == \"Férfi\" &\n          ICDCode == \"C18\",\n        .(Year, Esetszam = N, Lelekszam = Population)]\n\n     Year Esetszam Lelekszam\n    &lt;num&gt;    &lt;int&gt;     &lt;num&gt;\n 1:  2000        8   51602.0\n 2:  2001        4   47836.0\n 3:  2002        4   45296.5\n 4:  2003        4   43632.5\n 5:  2004        4   43085.0\n 6:  2005        5   43442.5\n 7:  2006        5   44511.5\n 8:  2007        6   46903.5\n 9:  2008        4   50505.5\n10:  2009        6   54015.0\n11:  2010        3   57445.5\n12:  2011        8   60721.0\n13:  2012        7   62471.5\n14:  2013        5   63746.5\n15:  2014        8   66250.5\n16:  2015       13   70511.5\n17:  2016       11   74622.0\n18:  2017        6   77902.0\n19:  2018       10   80555.0\n\n\nEz már utat mutat a következő, igazi újdonsághoz.\nElőtte még említsük meg, hogy a data table egyik jellegzetessége, hogy a RawData[, .(Year)] típusú hívások mindig data table-t adnak vissza10. Ha egyetlen változót választunk ki, de azt vektorként szeretnénk visszakapni (ez a kérdés nyilván csak egyetlen változó kiválasztásakor merül fel), akkor használjuk a RawData$Year vagy a RawData[[\"Year\"]] formát11.\nEz eddig nem nagy változás, még csak azt sem igazán lehet mondani, hogy az előzőhöz hasonló kényelmi továbbfejlesztés, hiszen ez a szintaktika nem sokkal tér el a korábbitól. Az igazán érdekes rész azonban most jön, a data.table ugyanis lehetővé tesz valamit, ami a data.frame-nél fel sem merült: nem csak passzívan kiválaszthatunk oszlopokat, hanem műveleteket is végezhetünk velük, így új oszlopokat hozva létre! Lényegében „on the fly”, azaz menet közben végezhetünk műveleteket és hozhatunk létre új oszlopokat, anélkül, hogy azokat fizikailag le kellene tárolnunk az adatbázisba. A data table vessző utáni pozíciójában tehát\nPéldául a rákos megbetegedéseknél fontos az incidencia, tehát a lélekszámhoz viszonyított előfordulás. (Értelemszerűen nem mindegy, hogy 10 vagy 10 ezer ember közül került ki 1 rákos adott évben.) Ezt tipikusan 100 ezer lakosra vonatkoztatva szokták megadni. Nézzük meg a következő data table-t használó megoldást:\n\nRawData[Age == 40 & County == \"Budapest\" & Sex == \"Férfi\" &\n          ICDCode == \"C18\",\n        .(Year, N, Population, Inc = N / Population * 1e5)]\n\n     Year     N Population       Inc\n    &lt;num&gt; &lt;int&gt;      &lt;num&gt;     &lt;num&gt;\n 1:  2000     8    51602.0 15.503275\n 2:  2001     4    47836.0  8.361903\n 3:  2002     4    45296.5  8.830704\n 4:  2003     4    43632.5  9.167478\n 5:  2004     4    43085.0  9.283974\n 6:  2005     5    43442.5 11.509467\n 7:  2006     5    44511.5 11.233052\n 8:  2007     6    46903.5 12.792222\n 9:  2008     4    50505.5  7.919930\n10:  2009     6    54015.0 11.108026\n11:  2010     3    57445.5  5.222341\n12:  2011     8    60721.0 13.175014\n13:  2012     7    62471.5 11.205110\n14:  2013     5    63746.5  7.843568\n15:  2014     8    66250.5 12.075381\n16:  2015    13    70511.5 18.436709\n17:  2016    11    74622.0 14.740961\n18:  2017     6    77902.0  7.701985\n19:  2018    10    80555.0 12.413879\n\n\nAzaz az Inc oszlopot létrehoztuk a nélkül, hogy előzetesen azt le kellett volna tárolnunk magába az adatbázisba! Menet közben számoltuk ki, és még nevet is adtunk neki. Az oszlopok tehát itt, a vessző utáni pozícióban úgy viselkednek egy data table-nél mintha szokásos változók lennének!\nEbből is adódik, hogy a lehetőségeink még ennél is bővebbek: nem csak egyszerű aritmetikai műveleteket végezhetünk egy oszloppal (vagy épp több oszloppal! – mint arra ez előbbi kód is példát mutat), hanem bármilyen R függvényt rájuk ereszthetünk! Tekintsünk példának a következő kódot, mely megadja, hogy a 40-45 éves budapesti férfiak körében összesen hány vastagbélrákos eset volt az adatbázis által lefedett 19 év alatt:\n\nRawData[Age == 40 & County == \"Budapest\" & Sex == \"Férfi\" &\n          ICDCode == \"C18\",\n        .(N = sum(N))]\n\n       N\n   &lt;int&gt;\n1:   121\n\n\nAz N oszlop egy vektor, tehát azon túl, hogy oszthatjuk – elemenként – egy másik vektorral, mint ahogy az előbbi esetben tettük, nyugodtan összegezhetjük is példának okáért. Ebből mellesleg az is látszik, hogy még az sem jelent problémát, ha a művelet által visszaadott eredménynek a hossza is eltér a bemenő változóétól! Hiszen a sum(N) 1 hosszú, míg a Year 19. (Az azonban fontos, hogy itt már a Year nem szerepel a kiválasztott oszlopok között: megtarthattuk volna a Year-t is, de mivel az 19 hosszú, így a mellette lévő oszlopban ugyanaz az összeg 19-szer meg lett volna ismételve.)\nA fenti példákban egyszerre szűrtünk sorokat és számoltunk oszlopokat. (Ez természetesen nem kötelező, lehet csak az egyiket csinálni a másik nélkül.) Egyetlen példa a data.table optimalizálására: ilyenkor nem azt csinálja, hogy leszűri az egész adatbázist, és aztán végzi az oszlopműveleteket, hanem először megnézi, hogy mely oszlopokra van egyáltalán szükség – például csak a Year-re, N-re és Population-re – és ilyenkor csak azokat szűri le, így kerülve el, hogy olyan oszlopok szűrését is el kelljen végeznie, amik később nem is jelennek meg az eredményben. Ez azért lehetséges, mert a data.table „egyben látja” az egész feladatot, és így tud ilyen optimalizálásokat tenni.\nVisszatérve, a dolog még jobban kombinálható: legyen a példa kedvéért a feladatunk az, hogy számoljuk ki az egész 19 éves periódusra az incidenciát. (Egy pillanatra érdemes itt megállni, és végiggondolni, hogy mi egyáltalán az ehhez szükséges művelet!) Íme a megvalósítás data.table használatával:\n\nRawData[Age == 40 & County == \"Budapest\" & Sex == \"Férfi\" &\n          ICDCode == \"C18\",\n        .(Inc = sum(N) / sum(Population) * 1e5)]\n\n       Inc\n     &lt;num&gt;\n1: 11.1515\n\n\nAmint láthatjuk, tetszőleges komplexitású műveletet, számítást elvégezhetünk a vessző után! És ezt szó szerint kell érteni: bármilyen R függvényt használhatunk az oszlopindexelés pozíciójában, a vessző után, bármilyen műveletet vagy számítást végezhetünk (tehát még csak olyan megkötés sincs, hogy csak bizonyos függvényeket, műveleteket tesz csak elérhetővé a data.table). Íme egy példa; lognormális eloszlást illesztünk az esetszámok különböző években mért értékeiből kapott eloszlásra:\n\nRawData[Age == 40 & County == \"Budapest\" & Sex == \"Férfi\" &\n          ICDCode == \"C18\",\n        .(fitdistrplus::fitdist(N, \"lnorm\")$estimate[\"meanlog\"])]\n\n         V1\n      &lt;num&gt;\n1: 1.772807\n\n\nSzépen látszik itt is, hogy nyugodtan használhatjuk az N-et csak így, minden további nélkül – ugyanúgy viselkedik, mint egy szokásos változó, ugyanúgy használhatjuk egy számítás során.\nRáadásul, ha visszaemlékszünk, akkor szerepelt, hogy a vessző utáni pozícióban egy listának kell szerepelnie – de ezt előállíthatja egy függvény is! Például a fitdistrplus::fitdist eredményének estimate nevű komponense egy vektor. De ha ez as.list-tel átalakítjuk, akkor egy listát kapunk, így közvetlenül átadható a vessző utáni pozícióban (természetesen ilyenkor . nem kell, hiszen az as.list eleve egy listát ad vissza!):\n\nRawData[Age == 40 & County == \"Budapest\" & Sex == \"Férfi\" &\n          ICDCode == \"C18\",\n        as.list(fitdistrplus::fitdist(N, \"lnorm\")$estimate)]\n\n    meanlog     sdlog\n      &lt;num&gt;     &lt;num&gt;\n1: 1.772807 0.3902478\n\n\nEz tehát már messze-messze nem csak egyszerűen oszlopkiválasztás, amire itt módunk van, ha data.table-t használunk.\nEgyetlen megjegyzés a végére: mi van akkor, ha kíváncsiak vagyunk arra, hogy hány sor van egy adattáblában (esetleg szűkítés után)? A RawData[Age == 40 & County == \"Budapest\" & Sex == \"Férfi\" & ICDCode == \"C18\", length(N)] kézenfekvő megoldás, de nem túl elegáns (miért pont az N hosszát néztük meg? bármi más is ugyanezt az eredményt adná!). Erre a célra a data.table bevezet egy speciális szimbólumot, a .N-et, ami egyszerűen visszaadja12 a sorok számát:\n\nRawData[Age == 40 & County == \"Budapest\" & Sex == \"Férfi\" &\n          ICDCode == \"C18\", .N]\n\n[1] 19",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Data table: egy továbbfejlesztett adatkeret</span>"
    ]
  },
  {
    "objectID": "datatable.html#csoportosítás-aggregáció",
    "href": "datatable.html#csoportosítás-aggregáció",
    "title": "5  Data table: egy továbbfejlesztett adatkeret",
    "section": "5.5 Csoportosítás (aggregáció)",
    "text": "5.5 Csoportosítás (aggregáció)\nA data.table második, rendkívül erőteljes bővítése a hagyományos data frame funkcionalitásához képest a csoportosítás (aggregáció) lehetősége. A data.table bevezet egy harmadik pozíciót a szögletes zárójelen belül: megtehetjük, hogy két vesszőt teszünk ki a szögletes zárójelen belül, ez esetben az első vessző előtt van a sorindexelés (ahogy eddig is), az első és a második vessző között az oszlopkiválasztás és -számítás (ahogy eddig is), viszont a második vessző után megadhatunk egy listát egy vagy több változóból. (A . ugyanúgy használható a list helyett. Megadhatunk sztring-vektort is, benne a változók neveivel; ez különösen jól jön akkor, ha gépi úton állítjuk elő, hogy mik ezek a változók.) Mi fog ilyenkor történni? A data.table elsőként végrehajtja a sorok szűrését, ha kértünk ilyet, ezután pedig az új, harmadik pozícióban megadott változó vagy változók szerint csoportokat képez. Mit jelent az, hogy „csoport”? Azok a sorai a táblának, amelyekben a csoportosító változó egy adott értéket vesz fel: ahány lehetséges értéke van a csoportosító változónak a táblában, annyi csoport képződik, úgy, hogy csoporton belül a csoportosító változó homogén lesz. Ezt követően a data.table végrehajtja a megadott oszlopkiválasztásokat és/vagy oszlopműveleteket csoportonként külön-külön, végül pedig a kapott eredményeket újra összerakja egy táblába, úgy, hogy mindegyik csoport eredménye mellé beteszi oszlopként azt, hogy ott mi volt a csoportosító változó értéke. Az egyes csoportok abban a sorrendben fognak szerepelni az eredményben, ahogy egymás után jöttek a kiinduló táblában.\nA jobb megértés kedvéért nézzünk egy gyakorlati példát! Kíváncsiak vagyunk az egész időintervallumra vonatkozó incidenciára, de az összes rák-típus esetén külön-külön megadva. Mit tudunk tenni? Fent láttuk a kódot, mely egy adott típusra ezt kiszámolja. Az remélhetőleg senkinek nem jut az eszébe, hogy kézzel lefuttassa először C00-val, aztán C01-gyel, aztán C02-vel… Működőképesebb megoldás ennek valamilyen R paranccsal történő automatizálása. Rosszabb esetben a for jut az eszünkbe, jobb esetben az apply család valamely tagja. (A for-ciklus rosszabb eset, mert az R-ben a legtöbb esetben illendő kerülni, és jelen esetben tényleg meg is oldható a probléma megfelelő apply használatával, így ez is a célszerű választás.) Ha azonban a data.table-t használjuk, akkor még csak erre sincs szükség!\nNézzük ugyanis meg a következő hívást:\n\nRawData[Age == 40 & County == \"Budapest\" & Sex == \"Férfi\",\n        .(Inc = sum(N) / sum(Population) * 1e5),\n        .(ICDCode)]\n\n    ICDCode         Inc\n     &lt;char&gt;       &lt;num&gt;\n 1:     C00  0.36864474\n 2:     C01  2.21186843\n 3:     C02  2.58051316\n 4:     C03  1.01377303\n 5:     C04  2.48835198\n 6:     C05  0.73728948\n 7:     C06  0.55296711\n 8:     C07  0.92161184\n 9:     C08  0.73728948\n10:     C09  1.65890132\n11:     C10  3.13348027\n12:     C11  1.19809540\n13:     C12  0.46080592\n14:     C13  4.42373685\n15:     C14  0.82945066\n16:     C15  4.14725330\n17:     C16  6.72776646\n18:     C17  1.75106250\n19:     C18 11.15150331\n20:     C19  2.58051316\n21:     C20  7.09641120\n22:     C21  0.55296711\n23:     C22  3.87076974\n24:     C23  1.01377303\n25:     C24  1.47457895\n26:     C25  7.37289475\n27:     C26  0.46080592\n28:     C30  0.64512829\n29:     C31  1.10593421\n30:     C32  7.46505593\n31:     C33  0.09216118\n32:     C34 30.78183558\n33:     C37  0.46080592\n34:     C38  1.10593421\n35:     C39  0.36864474\n36:     C40  1.01377303\n37:     C41  2.94915790\n38:     C43 17.41846385\n39:     C44 43.13143429\n40:     C45  0.64512829\n41:     C46  0.46080592\n42:     C47  0.00000000\n43:     C48  2.39619079\n44:     C49 10.78285857\n45:     C50  2.76483553\n46:     C51  0.00000000\n47:     C52  0.00000000\n48:     C53  0.00000000\n49:     C54  0.00000000\n50:     C55  0.00000000\n51:     C56  0.00000000\n52:     C57  0.00000000\n53:     C58  0.00000000\n54:     C60  0.92161184\n55:     C61  2.94915790\n56:     C62 22.11868425\n57:     C63  0.64512829\n58:     C64 12.25743752\n59:     C65  0.27648355\n60:     C66  0.00000000\n61:     C67  8.38666778\n62:     C68  0.18432237\n63:     C69  1.10593421\n64:     C70  0.55296711\n65:     C71  8.75531252\n66:     C72  1.10593421\n67:     C73  5.06886514\n68:     C74  0.73728948\n69:     C75  0.27648355\n70:     C76  2.67267435\n71:     C80  2.39619079\n72:     C81  3.40996382\n73:     C82  2.58051316\n74:     C83  3.96293093\n75:     C84  0.92161184\n76:     C85  4.42373685\n77:     C88  0.00000000\n78:     C90  2.21186843\n79:     C91  3.31780264\n80:     C92  4.51589803\n81:     C93  0.00000000\n82:     C94  0.18432237\n83:     C95  0.09216118\n84:     C96  1.56674013\n85:     C97  0.00000000\n86:     D00  0.46080592\n87:     D01  0.18432237\n88:     D02  0.09216118\n89:     D03  4.60805922\n90:     D04  1.75106250\n91:     D05  0.00000000\n92:     D06  0.00000000\n93:     D07  0.36864474\n94:     D09  0.27648355\n95:     D30  1.38241777\n96:     D33  6.26696054\n    ICDCode         Inc\n\n\nMi történt itt? Először is, a sor-szűrések közül kivettük a konkrét rák-típust – ez értelemszerű, hiszen az összes ráktípusra vonatkozó adatot szeretnénk kapni, épp ez volt a feladat, tehát ebben nyilván nem szűrhetjük le előzetesen az adatbázist. Másodszor, bekerült a harmadik pozíciója, csoportosító változóként a rák típusa. Mit jelent ez? Azt, hogy a szűrés után a data.table a leszűrt adatbázisból rák-típus szerint csoportokat képez, tehát szétszedi az adatbázist kis táblákra úgy, hogy mindegyikben egy adott rák-típus adatai legyenek, mindegyikre elvégzi a második pozícióban, az oszlopindexelésnél megadott műveleteket (jelen esetben: kiszámítja az incidenciákat), majd ezeket az eredményeket, ami itt most egyetlen sor lesz, újra összerakja egy nagy táblába, jelezve, hogy az adott eredmény melyik kódhoz tartozik.\nNagyon szájbarágós, de talán egyszer érdemes a dolgot megnézni lépésről-lépésre. A data.table elsőként leszűri a táblát a sorindex szerint:\n\nRawData[Age == 40 & County == \"Budapest\" & Sex == \"Férfi\"]\n\nKey: &lt;County, Sex, Age, Year&gt;\n        County    Sex   Age  Year ICDCode     N Population\n        &lt;char&gt; &lt;char&gt; &lt;num&gt; &lt;num&gt;  &lt;char&gt; &lt;int&gt;      &lt;num&gt;\n   1: Budapest  Férfi    40  2000     C00     1      51602\n   2: Budapest  Férfi    40  2000     C01     6      51602\n   3: Budapest  Férfi    40  2000     C02     2      51602\n   4: Budapest  Férfi    40  2000     C03     1      51602\n   5: Budapest  Férfi    40  2000     C04     2      51602\n  ---                                                     \n1820: Budapest  Férfi    40  2018     D06     0      80555\n1821: Budapest  Férfi    40  2018     D07     0      80555\n1822: Budapest  Férfi    40  2018     D09     2      80555\n1823: Budapest  Férfi    40  2018     D30     0      80555\n1824: Budapest  Férfi    40  2018     D33     4      80555\n\n\nEzt követően megnézi, hogy a csoportosító változó milyen értékeket vesz fel:\n\nunique(RawData[Age == 40 & County == \"Budapest\" &\n                 Sex == \"Férfi\"]$ICDCode)\n\n [1] \"C00\" \"C01\" \"C02\" \"C03\" \"C04\" \"C05\" \"C06\" \"C07\" \"C08\" \"C09\" \"C10\" \"C11\"\n[13] \"C12\" \"C13\" \"C14\" \"C15\" \"C16\" \"C17\" \"C18\" \"C19\" \"C20\" \"C21\" \"C22\" \"C23\"\n[25] \"C24\" \"C25\" \"C26\" \"C30\" \"C31\" \"C32\" \"C33\" \"C34\" \"C37\" \"C38\" \"C39\" \"C40\"\n[37] \"C41\" \"C43\" \"C44\" \"C45\" \"C46\" \"C47\" \"C48\" \"C49\" \"C50\" \"C51\" \"C52\" \"C53\"\n[49] \"C54\" \"C55\" \"C56\" \"C57\" \"C58\" \"C60\" \"C61\" \"C62\" \"C63\" \"C64\" \"C65\" \"C66\"\n[61] \"C67\" \"C68\" \"C69\" \"C70\" \"C71\" \"C72\" \"C73\" \"C74\" \"C75\" \"C76\" \"C80\" \"C81\"\n[73] \"C82\" \"C83\" \"C84\" \"C85\" \"C88\" \"C90\" \"C91\" \"C92\" \"C93\" \"C94\" \"C95\" \"C96\"\n[85] \"C97\" \"D00\" \"D01\" \"D02\" \"D03\" \"D04\" \"D05\" \"D06\" \"D07\" \"D09\" \"D30\" \"D33\"\n\n\nMajd ezek mindegyikére leszűkíti a (szűrt) táblát, lényegében kis táblákat készítve. Így néz ki a C00-hoz tartozó:\n\nRawData[Age == 40 & County == \"Budapest\" & Sex == \"Férfi\" &\n          ICDCode == \"C00\"]\n\nKey: &lt;County, Sex, Age, Year&gt;\n      County    Sex   Age  Year ICDCode     N Population\n      &lt;char&gt; &lt;char&gt; &lt;num&gt; &lt;num&gt;  &lt;char&gt; &lt;int&gt;      &lt;num&gt;\n 1: Budapest  Férfi    40  2000     C00     1    51602.0\n 2: Budapest  Férfi    40  2001     C00     1    47836.0\n 3: Budapest  Férfi    40  2002     C00     0    45296.5\n 4: Budapest  Férfi    40  2003     C00     0    43632.5\n 5: Budapest  Férfi    40  2004     C00     0    43085.0\n 6: Budapest  Férfi    40  2005     C00     0    43442.5\n 7: Budapest  Férfi    40  2006     C00     0    44511.5\n 8: Budapest  Férfi    40  2007     C00     0    46903.5\n 9: Budapest  Férfi    40  2008     C00     0    50505.5\n10: Budapest  Férfi    40  2009     C00     0    54015.0\n11: Budapest  Férfi    40  2010     C00     0    57445.5\n12: Budapest  Férfi    40  2011     C00     1    60721.0\n13: Budapest  Férfi    40  2012     C00     1    62471.5\n14: Budapest  Férfi    40  2013     C00     0    63746.5\n15: Budapest  Férfi    40  2014     C00     0    66250.5\n16: Budapest  Férfi    40  2015     C00     0    70511.5\n17: Budapest  Férfi    40  2016     C00     0    74622.0\n18: Budapest  Férfi    40  2017     C00     0    77902.0\n19: Budapest  Férfi    40  2018     C00     0    80555.0\n\n\nÍgy a C01-hez:\n\nRawData[Age == 40 & County == \"Budapest\" & Sex == \"Férfi\" &\n          ICDCode == \"C01\"]\n\nKey: &lt;County, Sex, Age, Year&gt;\n      County    Sex   Age  Year ICDCode     N Population\n      &lt;char&gt; &lt;char&gt; &lt;num&gt; &lt;num&gt;  &lt;char&gt; &lt;int&gt;      &lt;num&gt;\n 1: Budapest  Férfi    40  2000     C01     6    51602.0\n 2: Budapest  Férfi    40  2001     C01     1    47836.0\n 3: Budapest  Férfi    40  2002     C01     0    45296.5\n 4: Budapest  Férfi    40  2003     C01     3    43632.5\n 5: Budapest  Férfi    40  2004     C01     2    43085.0\n 6: Budapest  Férfi    40  2005     C01     0    43442.5\n 7: Budapest  Férfi    40  2006     C01     3    44511.5\n 8: Budapest  Férfi    40  2007     C01     2    46903.5\n 9: Budapest  Férfi    40  2008     C01     0    50505.5\n10: Budapest  Férfi    40  2009     C01     2    54015.0\n11: Budapest  Férfi    40  2010     C01     0    57445.5\n12: Budapest  Férfi    40  2011     C01     3    60721.0\n13: Budapest  Férfi    40  2012     C01     1    62471.5\n14: Budapest  Férfi    40  2013     C01     1    63746.5\n15: Budapest  Férfi    40  2014     C01     0    66250.5\n16: Budapest  Férfi    40  2015     C01     0    70511.5\n17: Budapest  Férfi    40  2016     C01     0    74622.0\n18: Budapest  Férfi    40  2017     C01     0    77902.0\n19: Budapest  Férfi    40  2018     C01     0    80555.0\n\n\nÉs így tovább.\nEzt követően minden kis táblára elvégzi az oszlopindexelésnél kijelölt műveletet. Így fog kinézni az eredmény a C00-s kis táblára:\n\nRawData[Age == 40 & County == \"Budapest\" & Sex == \"Férfi\" &\n          ICDCode == \"C00\",\n        .(Inc = sum(N) / sum(Population) * 1e5)]\n\n         Inc\n       &lt;num&gt;\n1: 0.3686447\n\n\nÍgy a C01-es kis táblára:\n\nRawData[Age == 40 & County == \"Budapest\" & Sex == \"Férfi\" &\n          ICDCode == \"C01\",\n        .(Inc = sum(N) / sum(Population) * 1e5)]\n\n        Inc\n      &lt;num&gt;\n1: 2.211868\n\n\nMajd ezeket a kis táblákat egymás alá rendezi, abban a sorrendben, ahogy az eredeti táblában előfordultak a csoportosító változó értékei, és úgy, hogy mindegyikhez melléírja, hogy az adottnál mi volt a csoportosító változó értéke, tehát jelen esetben, hogy melyik ráktípushoz tartozik.\nÍgy kaptuk a fent látható táblát (menjünk vissza és ellenőrizzük)…!\nNézzünk meg – most már nagyon részletes levezetés nélkül – még egy példát csoportosításra. Kíváncsiak vagyunk egy adott ráktípus korspecifikus incidenciájára, tehát, hogy mennyi az incidencia adott életkorban. Ha mindezt rögzített évre, nemre és megyére kérdezzük, akkor célt érhetünk így:\n\nRawData[Year == 2010 & County == \"Budapest\" &\n          Sex == \"Férfi\" & ICDCode == \"C18\",\n        .(Age, Inc = N / Population * 1e5)]\n\n      Age        Inc\n    &lt;num&gt;      &lt;num&gt;\n 1:     0   0.000000\n 2:     5   0.000000\n 3:    10   0.000000\n 4:    15   0.000000\n 5:    20   1.960054\n 6:    25   3.072716\n 7:    30   2.321088\n 8:    35  11.088472\n 9:    40   5.222341\n10:    45  23.579344\n11:    50  37.503585\n12:    55  79.089038\n13:    60 130.617667\n14:    65 303.122158\n15:    70 292.659728\n16:    75 337.025636\n17:    80 456.403917\n18:    85 320.454129\n\n\nA dolog azonban nagyon nem szerencsés: kizárólag azért fog működni, mert a leszűkítés után egy adott életkorhoz már csak egyetlen sor tartozik. De ha ez nem így lenne, például kitörlünk valamit a feltételek közül, akkor teljesen rossz eredményt fog adni, hiszen ilyenkor ugyanaz az életkor többször fog megjelenni az eredményben, míg nekünk össze kellene adnunk az adott életkorhoz tartozó különböző megfigyeléseket.\nA megoldás a csoportosítás az életkor szerint, és az összeadás adott életkoron belül:\n\nRawData[Year == 2010 & County == \"Budapest\" &\n          Sex == \"Férfi\" & ICDCode == \"C18\",\n        .(Inc = sum(N) / sum(Population) * 1e5), .(Age)]\n\n      Age        Inc\n    &lt;num&gt;      &lt;num&gt;\n 1:     0   0.000000\n 2:     5   0.000000\n 3:    10   0.000000\n 4:    15   0.000000\n 5:    20   1.960054\n 6:    25   3.072716\n 7:    30   2.321088\n 8:    35  11.088472\n 9:    40   5.222341\n10:    45  23.579344\n11:    50  37.503585\n12:    55  79.089038\n13:    60 130.617667\n14:    65 303.122158\n15:    70 292.659728\n16:    75 337.025636\n17:    80 456.403917\n18:    85 320.454129\n\n\nEz immár működik másféle szűréssel is, például ha Budapest helyett az egész országra vagyunk kíváncsiak:\n\nRawData[Year == 2010 & Sex == \"Férfi\" & ICDCode == \"C18\",\n        .(Inc = sum(N) / sum(Population) * 1e5), .(Age)]\n\n      Age         Inc\n    &lt;num&gt;       &lt;num&gt;\n 1:     0   0.4013437\n 2:     5   0.0000000\n 3:    10   0.3909763\n 4:    15   0.3278087\n 5:    20   1.2121488\n 6:    25   2.2652654\n 7:    30   3.2732344\n 8:    35   7.1454000\n 9:    40  11.2810011\n10:    45  21.7613797\n11:    50  46.2794518\n12:    55  94.8719665\n13:    60 130.8683356\n14:    65 246.5976935\n15:    70 293.1432072\n16:    75 367.2073711\n17:    80 347.1158754\n18:    85 323.4103513\n\n\nÉrdemes végiggondolni (ez általában is hasznos): ilyenkor az életkor szerinti kis táblákban 20 sor lesz – az egyes megyékkel – és ezek fölött fogunk összegezni.\nMegjegyzendő, hogy a csoportosító változónak nevet is adhatunk:\n\nRawData[Year == 2010 & Sex == \"Férfi\" & ICDCode == \"C18\",\n        .(Inc = sum(N) / sum(Population) * 1e5),\n        .(Eletkor = Age)]\n\n    Eletkor         Inc\n      &lt;num&gt;       &lt;num&gt;\n 1:       0   0.4013437\n 2:       5   0.0000000\n 3:      10   0.3909763\n 4:      15   0.3278087\n 5:      20   1.2121488\n 6:      25   2.2652654\n 7:      30   3.2732344\n 8:      35   7.1454000\n 9:      40  11.2810011\n10:      45  21.7613797\n11:      50  46.2794518\n12:      55  94.8719665\n13:      60 130.8683356\n14:      65 246.5976935\n15:      70 293.1432072\n16:      75 367.2073711\n17:      80 347.1158754\n18:      85 323.4103513\n\n\nAmi azonban sokkal izgalmasabb, hogy műveletet is végezhetünk! Itt is igaz, hogy nem kell a változót külön letárolni, hanem menet közben kiszámolhatjuk, majd építhetünk is rá rögtön (jelen esetben egy csoportosítást). Például, ha ki akarjuk számolni az incidenciát külön a 70 év alattiak és felettiek körében:\n\nRawData[Year == 2010 & Sex == \"Férfi\" & ICDCode == \"C18\",\n        .(Inc = sum(N) / sum(Population) * 1e5),\n        .(Idos = Age &gt; 70)]\n\n     Idos       Inc\n   &lt;lgcl&gt;     &lt;num&gt;\n1:  FALSE  43.83737\n2:   TRUE 352.54419",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Data table: egy továbbfejlesztett adatkeret</span>"
    ]
  },
  {
    "objectID": "datatable.html#indexelések-láncolása-egymás-után",
    "href": "datatable.html#indexelések-láncolása-egymás-után",
    "title": "5  Data table: egy továbbfejlesztett adatkeret",
    "section": "5.6 Indexelések láncolása egymás után",
    "text": "5.6 Indexelések láncolása egymás után\nA data.table következő újítása, hogy megengedi egy már indexelt tábla (RawData[...]) újabb indexelését. Tehát használhatjuk a RawData[...][...] alakot, ahol a második indexelés pontosan ugyanúgy fog viselkedni, mint az első (ugyanúgy használhatunk sorindexelést, szűrést és rendezést, oszlopkiválasztást és -transzformációt, csoportosítást), de úgy, hogy az az első, már indexelt táblára vonatkozik! Lényegében mintha elmentettük volna a RawData[...]-t egy változóba, és utána azt a változót indexelnénk szokásos módon – csak itt nem kell semmit külön elmenteni. Az, hogy a második indexelés már az első indexelésben átalakított táblára vonatkozik, egy kritikusan fontos előny, amint az rögtön világossá is fog válni.\nHa pontosak akarunk lenni, akkor ezt az egymás utáni többszöri indexelést igazából a hagyományos data frame is megengedi, tehát például a RawDataDF[101:200,][5:15,] egy teljesen szabályos hívás (és természetesen egyenértékű lesz azzal, hogy RawDataDF[105:115,]). A probléma az, hogy a használhatósága nagyon korlátozott, mert a második indexben, ha változóra hivatkozunk, az az eredeti adatkeret változója tud csak lenni, nem az első indexelésben már áttranszformálté! (Értelemszerűen, hiszen az nincs is elmentve, nincs is semmilyen külön neve, ahogy hivatkozhatnánk rá.) Ha csak a legegyszerűbb transzformációt, a sorok szűrését vesszük: a RawDataDF[RawDataDF$Sex == \"Férfi\",][RawDataDF$Year == 2010,] nem fog működni, ez onnan is kapásból látszik, hogy a RawDataDF$Year == 2010 ugyanolyan hosszú, mint a a RawDataDF, viszont a RawDataDF[RawDataDF$Sex == \"Férfi\",] már rövidebb, tehát ez így biztosan nem lehet jó, mert az adattáblát hosszabb vektorral próbáljuk indexelni, mint ahány sora van. Data frame használatával erre a problémára nincs megoldás, hiszen a RawDataDF[RawDataDF$Sex == \"Férfi\",] táblázat Year változójára nem tudunk sehogy sem hivatkozni a második indexelésben, hiszen az nincs elmentve, nincs is külön neve, amivel hivatkozhatnánk.\nA data table esetében azonban, kihasználva, hogy a változóra hivatkozhatunk csak a nevével, a táblázat neve nélkül, erre nagyon egyszerű a megoldás: annyi a feladat, hogy a második indexben szereplő Year alatt a data.table azt értse, hogy az első indexelés után kapott táblázat Year nevű változója (ne azt, hogy az eredetié). És így is van megírva a data.table, ezért szerepelt korábban az a megfogalmazás, hogy a második index az első indexeléssel már transzformált táblára vonatkozik. Így aztán a következő hívás tökéletesen működik data table-lel:\n\nRawData[Sex == \"Férfi\"][Year == 2010]\n\nKey: &lt;County, Sex, Age, Year&gt;\n              County    Sex   Age  Year ICDCode     N Population\n              &lt;char&gt; &lt;char&gt; &lt;num&gt; &lt;num&gt;  &lt;char&gt; &lt;int&gt;      &lt;num&gt;\n    1: Baranya megye  Férfi     0  2010     C00     0     9430.0\n    2: Baranya megye  Férfi     0  2010     C01     0     9430.0\n    3: Baranya megye  Férfi     0  2010     C02     0     9430.0\n    4: Baranya megye  Férfi     0  2010     C03     0     9430.0\n    5: Baranya megye  Férfi     0  2010     C04     0     9430.0\n   ---                                                          \n34556:    Zala megye  Férfi    85  2010     D06     0     1447.5\n34557:    Zala megye  Férfi    85  2010     D07     0     1447.5\n34558:    Zala megye  Férfi    85  2010     D09     0     1447.5\n34559:    Zala megye  Férfi    85  2010     D30     0     1447.5\n34560:    Zala megye  Férfi    85  2010     D33     4     1447.5\n\n\nEz még nem a legátütőbb példa – bár sokszor az ilyenek is nagyon jól jönnek – hiszen használhattunk volna egyszerűen & jelet és egyetlen indexelést. A dolog igazi erejét az adja, hogy – ismét csak abból fakadóan, hogy a második index már az elsőnek indexelt táblát látja, neki nem is számít, hogy az nem egy lementett tábla, hanem egy már átalakított – módunk van menet közben létrehozott változókra is hivatkozni! Például miután kiszámoltuk rák-típusonként az incidenciát, szeretnénk a táblázatot az incidenciák szerint növekvő sorba rakni. Íme a megoldás:\n\nRawData[Age == 40 & County == \"Budapest\" & Sex == \"Férfi\",\n        .(Inc = sum(N) / sum(Population) * 1e5),\n        .(ICDCode)][order(Inc)]\n\n    ICDCode         Inc\n     &lt;char&gt;       &lt;num&gt;\n 1:     C47  0.00000000\n 2:     C51  0.00000000\n 3:     C52  0.00000000\n 4:     C53  0.00000000\n 5:     C54  0.00000000\n 6:     C55  0.00000000\n 7:     C56  0.00000000\n 8:     C57  0.00000000\n 9:     C58  0.00000000\n10:     C66  0.00000000\n11:     C88  0.00000000\n12:     C93  0.00000000\n13:     C97  0.00000000\n14:     D05  0.00000000\n15:     D06  0.00000000\n16:     C33  0.09216118\n17:     C95  0.09216118\n18:     D02  0.09216118\n19:     C68  0.18432237\n20:     C94  0.18432237\n21:     D01  0.18432237\n22:     C65  0.27648355\n23:     C75  0.27648355\n24:     D09  0.27648355\n25:     C00  0.36864474\n26:     C39  0.36864474\n27:     D07  0.36864474\n28:     C12  0.46080592\n29:     C26  0.46080592\n30:     C37  0.46080592\n31:     C46  0.46080592\n32:     D00  0.46080592\n33:     C06  0.55296711\n34:     C21  0.55296711\n35:     C70  0.55296711\n36:     C30  0.64512829\n37:     C45  0.64512829\n38:     C63  0.64512829\n39:     C05  0.73728948\n40:     C08  0.73728948\n41:     C74  0.73728948\n42:     C14  0.82945066\n43:     C07  0.92161184\n44:     C60  0.92161184\n45:     C84  0.92161184\n46:     C03  1.01377303\n47:     C23  1.01377303\n48:     C40  1.01377303\n49:     C31  1.10593421\n50:     C38  1.10593421\n51:     C69  1.10593421\n52:     C72  1.10593421\n53:     C11  1.19809540\n54:     D30  1.38241777\n55:     C24  1.47457895\n56:     C96  1.56674013\n57:     C09  1.65890132\n58:     C17  1.75106250\n59:     D04  1.75106250\n60:     C01  2.21186843\n61:     C90  2.21186843\n62:     C48  2.39619079\n63:     C80  2.39619079\n64:     C04  2.48835198\n65:     C02  2.58051316\n66:     C19  2.58051316\n67:     C82  2.58051316\n68:     C76  2.67267435\n69:     C50  2.76483553\n70:     C41  2.94915790\n71:     C61  2.94915790\n72:     C10  3.13348027\n73:     C91  3.31780264\n74:     C81  3.40996382\n75:     C22  3.87076974\n76:     C83  3.96293093\n77:     C15  4.14725330\n78:     C13  4.42373685\n79:     C85  4.42373685\n80:     C92  4.51589803\n81:     D03  4.60805922\n82:     C73  5.06886514\n83:     D33  6.26696054\n84:     C16  6.72776646\n85:     C20  7.09641120\n86:     C25  7.37289475\n87:     C32  7.46505593\n88:     C67  8.38666778\n89:     C71  8.75531252\n90:     C49 10.78285857\n91:     C18 11.15150331\n92:     C64 12.25743752\n93:     C43 17.41846385\n94:     C62 22.11868425\n95:     C34 30.78183558\n96:     C44 43.13143429\n    ICDCode         Inc\n\n\nHiába nem is létezik Inc nevű változó az eredeti adattáblában, ez a hívás mégis tökéletesen fog működni! Megint csak: azért, mert a második index már az első indexeléssel átalakított táblát kapja meg, és azt látja, pontosan ugyanúgy, mintha az egy lementett tábla lenne.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Data table: egy továbbfejlesztett adatkeret</span>"
    ]
  },
  {
    "objectID": "datatable.html#referencia-szemantika",
    "href": "datatable.html#referencia-szemantika",
    "title": "5  Data table: egy továbbfejlesztett adatkeret",
    "section": "5.7 Referencia szemantika",
    "text": "5.7 Referencia szemantika\nA data.table bevezet egy új megközelítést arra, hogy új változót definiáljunk egy táblában – ám hamar ki fog derülni, hogy itt jóval többről van szó, mint egyszerűen egy alternatív jelölésről.\nPéldául számoljuk ki, és ezúttal a táblázatban is tároljuk el az incidenciákat13:\n\nRawData$Inc &lt;- RawData$N / RawData$Population * 1e5\n\nA data.table által bevezett új megoldás esetén az értékadás jele a :=, de ami talán még fontosabb, hogy ezt, elsőre elég meglepő módon, úgy kell megadni, mintha indexelnénk, tehát szögleges zárójelek között! A második pozícióba, az oszlopindex helyébe kell kerüljön:\n\nRawData[, Inc2 := N / Population * 1e5]\n\nA kettő valóban ugyanazt eredményezi:\n\nidentical(RawData$Inc, RawData$Inc2)\n\n[1] TRUE\n\n\nEbben van egy újdonság: az összes eddigi példában új táblát hoztunk létre (még ha csak ki is írattuk, és nem mentettük el változóba), ez az első eset, ahol meglevő táblát módosítunk. Ez nagyon fontos: mint láthatjuk is, nem kell az eredményt belementenünk egy változóba, azért nem, mert az utasítás lefuttatásakor maga az eredeti tábla módosult! Ezt szokták az informatikában referencia szerinti módosításnak14 hívni. (És igen, ezt az indexelés szintaktikájával éri el a data.table, még ha elég meglepő is első látásra.)\nKiíratás ilyenkor ugyanúgy nincs, mint általában az értékadásos utasításoknál R-ben. Ha szeretnénk az értékadás után rögtön ki is íratni a táblát akkor egy [] jelet kell tennünk a parancs után, pl. RawData[, Inc2 := N / Population * 1e5][].\nHasználhatjuk ezt a megoldást meglevő változó felülírására, nem csak új létrehozására. Például, ha meggondoljuk magunkat, és az incidenciát per millió fő mértékegységben szeretnénk megadni:\n\nRawData[, Inc2 := Inc2 * 10]\n\nEgyszerre több változót is definiálhatunk (lehet vegyesen új definiálása és régi felülírása, ennek nincs jelentősége), ennek módszere:\n\nRawData[, c(\"logPop\", \"sqrtPop\") := list(log(Population),\n                                         sqrt(Population))]\n\nMivel az értékadás bal oldalán sztring-vektor áll, így könnyen előállítható gépi úton is. A jobb oldalon pedig lista szerepel, így itt is igaz, hogy nem muszáj kézzel felsorolni, bármilyen olyan függvény szerepelhet ott, ami listát ad vissza.\nVáltozó törölhető is ilyen módon:\n\nRawData[, Inc2 := NULL]\n\nHa több változót törölnénk:\n\nRawData[, c(\"logPop\", \"sqrtPop\") := NULL]\n\nMi értelme van mindennek? Az első válasz az, hogy bizonyos esetekben gyorsabb15. A második, hogy mindez kombinálható a data.table többi elemével, tehát a sorindexeléssel és a csoportosítással.\nPéldául szeretnénk a „Budapest” kifejezést lecserélni arra, hogy „Főváros” a megye változóban. Ezt megoldhatjuk így:\n\nRawData[County == \"Budapest\", County := \"Főváros\"]\n\nTehát: ha az értékadást szűréssel kombináljuk, akkor a nem kiválasztott soroknál nem változik az érték. (Ha pedig nem meglevő változót módosítunk, hanem újat hozunk létre, akkor a nem kiválasztott soroknál NA kerül az új változóba.)\nEzt könnyen megoldhattuk volna másképp is, de nézzük egy izgalmasabb példát. Szeretnénk minden nemre, életkorra, megyére és ráktípusra eltárolni, hogy az adott nemből, életkorból, megyéből és ráktípusból mi volt a legkisebb feljegyzett incidencia (a különböző évek közül, tehát). Ezt data.table nélkül csak macerásabban tudnánk megtenni, de a data.table használatával nagyon egyszerű (és nagyon logikus) a megoldás:\n\nRawData[, MinInc := min(Inc), .(County, Sex, Age, ICDCode)]\n\nA csoportosító változót kell használnunk, ami teljesen logikus is: képezi a csoportokat nem, életkor, megye és ráktípus szerint (tehát az egyes csoportokban a különböz évek fognak szerepelni), veszi azok körében az Inc minimumát, és azt menti el MinInc néven – az adott csoport különböző soraihoz mindig ugyanazt az értéket. Íme:\n\nRawData[ICDCode == \"C18\" & Age == 70 & County == \"Főváros\"]\n\n     County    Sex   Age  Year ICDCode     N Population      Inc   MinInc\n     &lt;char&gt; &lt;char&gt; &lt;num&gt; &lt;num&gt;  &lt;char&gt; &lt;int&gt;      &lt;num&gt;    &lt;num&gt;    &lt;num&gt;\n 1: Főváros  Férfi    70  2000     C18    97    30697.5 315.9866 217.0223\n 2: Főváros  Férfi    70  2001     C18   111    32326.5 343.3715 217.0223\n 3: Főváros  Férfi    70  2002     C18   108    31711.5 340.5705 217.0223\n 4: Főváros  Férfi    70  2003     C18    99    30984.0 319.5198 217.0223\n 5: Főváros  Férfi    70  2004     C18   100    30205.5 331.0655 217.0223\n 6: Főváros  Férfi    70  2005     C18    97    29194.5 332.2544 217.0223\n 7: Főváros  Férfi    70  2006     C18    90    28123.5 320.0171 217.0223\n 8: Főváros  Férfi    70  2007     C18    96    27422.5 350.0775 217.0223\n 9: Főváros  Férfi    70  2008     C18    95    27080.5 350.8059 217.0223\n10: Főváros  Férfi    70  2009     C18   102    26957.0 378.3804 217.0223\n11: Főváros  Férfi    70  2010     C18    80    27335.5 292.6597 217.0223\n12: Főváros  Férfi    70  2011     C18    97    28288.0 342.9016 217.0223\n13: Főváros  Férfi    70  2012     C18    89    30601.5 290.8354 217.0223\n14: Főváros  Férfi    70  2013     C18   118    32451.0 363.6252 217.0223\n15: Főváros  Férfi    70  2014     C18   108    34269.5 315.1490 217.0223\n16: Főváros  Férfi    70  2015     C18   103    35428.0 290.7305 217.0223\n17: Főváros  Férfi    70  2016     C18   107    35831.5 298.6199 217.0223\n18: Főváros  Férfi    70  2017     C18   101    36012.0 280.4621 217.0223\n19: Főváros  Férfi    70  2018     C18    78    35941.0 217.0223 217.0223\n20: Főváros     Nő    70  2000     C18   115    52434.0 219.3233 161.1007\n21: Főváros     Nő    70  2001     C18    99    53138.5 186.3056 161.1007\n22: Főváros     Nő    70  2002     C18    95    51751.0 183.5713 161.1007\n23: Főváros     Nő    70  2003     C18   110    50498.5 217.8283 161.1007\n24: Főváros     Nő    70  2004     C18    92    49073.0 187.4758 161.1007\n25: Főváros     Nő    70  2005     C18   102    47308.5 215.6061 161.1007\n26: Főváros     Nő    70  2006     C18    74    45934.0 161.1007 161.1007\n27: Főváros     Nő    70  2007     C18    95    45165.0 210.3399 161.1007\n28: Főváros     Nő    70  2008     C18    94    44594.5 210.7883 161.1007\n29: Főváros     Nő    70  2009     C18    84    44558.5 188.5162 161.1007\n30: Főváros     Nő    70  2010     C18    81    45258.5 178.9719 161.1007\n31: Főváros     Nő    70  2011     C18   101    46479.0 217.3024 161.1007\n32: Főváros     Nő    70  2012     C18   104    48132.0 216.0725 161.1007\n33: Főváros     Nő    70  2013     C18   134    50451.0 265.6042 161.1007\n34: Főváros     Nő    70  2014     C18   124    52854.0 234.6085 161.1007\n35: Főváros     Nő    70  2015     C18    94    54534.5 172.3680 161.1007\n36: Főváros     Nő    70  2016     C18   120    55317.5 216.9295 161.1007\n37: Főváros     Nő    70  2017     C18    95    55986.5 169.6838 161.1007\n38: Főváros     Nő    70  2018     C18   113    56508.0 199.9717 161.1007\n     County    Sex   Age  Year ICDCode     N Population      Inc   MinInc",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Data table: egy továbbfejlesztett adatkeret</span>"
    ]
  },
  {
    "objectID": "datatable.html#footnotes",
    "href": "datatable.html#footnotes",
    "title": "5  Data table: egy továbbfejlesztett adatkeret",
    "section": "",
    "text": "Arra azért vigyázni kell, hogy van példa arra, hogy pontosan ugyanaz a hívás mást ad vissza a data frame-nél és data table-nél. Egyébként ez a válasz arra a gyakran felmerülő kérdésre, hogy ha olyan jó a data.table, akkor miért nem győzik meg egyszerűen a fejlesztői az R fejlesztőit, hogy építsék be a tulajdonságait az R-es alap data frame-be is. Egyébként volt példa ilyenre is, de az előbbi ok miatt ez nem lehet általános, hiszen ez azt jelentené, hogy meglevő kódok működése is megváltozna, ami végeláthatlan sok R kód működését ronthatná el. Ilyen módosítást ma már nem igen lehet megtenni a data.frame-mel.↩︎\nA kód folytatható, ami finomabb felbontást ad, például a C00.0 a felső ajak külső felszínének daganata, a C00.1 az alsó ajak külső felszínének daganata stb., de a táblázatunk a háromjegyű besorolást tartalmazza.↩︎\nEz ún. évközepi lélekszám, tehát az év alatti – folyamatosan változó – lélekszámok átlaga. Ezért lehet az értéke törtszám is.↩︎\nEzek egy részénél nem kell külön függvényt hívni, csak „maga a data table” gyorsabb lesz mint a data frame. Más részénél szükség van egy külön függvényre, például a táblaegyesítésnél a merge-re. De ez is gyorsabb lesz, aminek a hátterében az van, hogy a data.table-nek van saját, ugyanilyen nevű függvénye (data.table::merge), és ez fog a data frame-hez tartozó alapváltozat, tehát a base::merge helyett futni.↩︎\nEgész pontosan annyit, amennyi a max.print opció értéke; ez a getOption(\"max.print\") paranccsal kérdezhető le. Az alapbeállítása tipikusan 1000.↩︎\nA precizitás kedvéért: ezt csak akkor teszi, ha a sorok száma nagyobb mint a datatable.print.nrows opció értéke, ami alapbeállítás szerint 100. De ez is logikus: kis adatbázisnál érdemes az egészet kiíratni, hiszen úgy is áttekinthető, nagyoknál lesz fontos csak az első néhány és az utolsó néhány sor kiíratása.↩︎\nEgyébként ez utóbbi esetben nem ugyanaz az order fut le: a data.table definiál egy saját order-t, tehát az előbbi esetben a base::order, az utóbbinál a data.table::order fut. A data.table csomag order-je egyébként is okosabb, például sokkal kényelmesebb ha több változó szerint és változó irányban kell rendeznünk: egyszerűen fel kell sorolnunk az order-en belül a változókat, és amelyik szerint csökkenő sorrendben akarunk rendezni, ott ki kell tennünk a változó neve elé egy - jelet.↩︎\nValójában van egy különbség, ami akkor jelentkezik, ha a kiválasztandó oszlopok neveit eltároljuk egy változóban, és az indexelésnél ezt a változót szeretnénk felhasználni ahelyett, hogy kézzel beírjuk a neveket. Legyen például colsel &lt;- c(\"Year\", \"N\", \"Population\"). Ekkor a data frame-nél mindegy, hogy a RawDataDF[, c(\"Year\", \"N\", \"Population\")] vagy a RawDataDF[, colsel] formát használjuk, az eredmény ugyanaz lesz. Ami logikus is, hiszen látszólag ugyanazt írtuk be kétszer. Nagyon meglepő módon azonban a data table-nél nem mindegy: a RawData[, c(\"Year\", \"N\", \"Population\")] működni fog, de a RawData[, colsel] nem! Ennek az az oka, hogy RawData[, colsel] összeakad egy szintaktikával, amit később fogunk látni, és amelyben ez azt jelentené, hogy „válaszd ki a colsel nevű oszlopot és add vissza vektorként”. Ami természetesen nem fog sikerülni, hiszen ilyen nevű oszlop nincs. Van azonban megoldás: ha erre volna szükségünk akkor vagy a RawData[, ..colsel] vagy a RawData[, colsel, with = FALSE] alakot kell használnunk.↩︎\nEz elsőre meglepő lehet, de valójában teljesen logikus: ha visszaemlékszünk, akkor már a data.frame-nél is láttuk, hogy az igazából az oszlopokból, mint vektorokból alkotott lista. Innen nézve teljesen érthető, hogy az oszlopokat egy lista elemeiként kell felsorolni!↩︎\nEz nem nyilvánvaló: a RawDataDF[, \"Year\"] egy vektor lesz! Természetesen a RawDataDF[, c(\"Year\", \"County\")] megint csak data frame; vagyis lényegében az történik, hogy a data frame automatikusan egyszerűsít: ha lehet – azaz egyetlen változót (oszlopot) választottunk ki – akkor egyszerűsíti vektorrá, ha nem, mert többet, akkor marad a data frame. Ez kényelmes is lehet, de közben mégis csak egy inkonzisztencia, hogy ugyanolyan típusú hívások eredménye teljesen eltérő adatstruktúra is lehet. Ezzel szemben a data.table-nél a RawData[, .(...)] típusú hívások mindig data table-t adnak vissza.↩︎\nElvileg a RawData[, Year] is használható, de ezt talán jobb kerülni, ritkán fordul elő.↩︎\nÉszrevehető, hogy az eredmény egy szám lesz, nem egy data table. Ennek az oka, hogy a .N – hiába van a nevében egy . – nem egy lista. Ha data frame-et szeretnénk visszakapni, akkor a korábbiakkal összhangban azt kell írnunk, hogy .(.N).↩︎\nAz összes fenti esetben ezt el tudtuk kerülni, és jobb is elkerülni: gondoljunk arra, hogy ha csoportosítást is csinálunk, akkor ezekkel az előre kiszámolt rétegenkénti incidenciákkal nem megyünk semmire. (Általában is igaz, hogy a kiszámítható dolgok közül csak azokat érdemes fizikailag letárolni az adatbázisban, amik kiszámítása sok időt venne igénybe.) Tehát ez most szigorúan csak illusztratív példa új változó létrehozására.↩︎\nEz problémát jelenthet akkor, ha egy függvényen belül csinálunk ilyet, hiszen ez azt fogja maga után vonni, hogy a bemenetként átadott adattábla át fog alakulni. Ez esetben a copy függvény segíthet: ezzel készíthetünk első lépésben egy másolatot a tábláról, és ha utána azon dolgozunk, akkor az eredeti, bemenetként megkapott tábla nem fog átalakulni.↩︎\nAz R a 3.1.0-s verzió előtt minden ilyen változó-értékadási műveletnél deep copy-t csinált az adatbázisról, ami azt jelenti, hogy nem csak a memóriamutatókat frissítette (ez lenne a shallow copy), hanem az egész adatbázist fizikailag átmásolta egy másik memóriaterületre. Ez nagyon gazdaságtalan, pláne, mert értelmetlen is, hiszen egy új változó definiálásától a meglevő tartalom maradhatna ugyanott. Ezt a 3.1.0-s verzióban orvosolták, de az továbbra is megmaradt, hogy nem az egész oszlop kap értéket, csak egy része, akkor deep copy készül. Ezzel szemben a data.table minden esetben és minden verzióban shallow copy-t csinál értékadásnál.↩︎",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Data table: egy továbbfejlesztett adatkeret</span>"
    ]
  }
]